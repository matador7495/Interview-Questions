[
  {
    "title": "1- تفاوت عملگرهای == و === ؟",
    "answer": "<p>عملگرهای == و === در جاوااسکریپت برای مقایسه مقادیر استفاده می‌شوند، اما تفاوت اصلی بین آنها در نحوه انجام مقایسه و نوع داده‌هایی که توانایی مقایسه آنها را دارند است <br /> <strong> == :</strong> این عملگر برای مقایسه مقادیر استفاده می‌شود. زمانی که از این عملگر استفاده می‌کنید، داده‌ها را با توجه به مقدار آنها مقایسه می‌کند. اگر مقادیر دو متغیر یکسان باشند، مقایسه موفق خواهد بود. <br /> <strong> === :</strong> این عملگر نیز برای مقایسه مقادیر استفاده می‌شود، اما با این تفاوت که علاوه بر مقایسه مقادیر، نوع داده‌ها نیز بررسی می‌شود. اگر دو مقدار نه تنها مساوی باشند بلکه همچنین نوع داده‌های آنها نیز یکسان باشد، مقایسه با === موفق خواهد بود. این عملگر به عنوان 'مقایسه دقیق' شناخته می‌شود. <br /> به عنوان مثال: <code> console.log(5 == '5'); // true <br /> console.log(5 === '5'); // false </code> در مثال بالا، در مقایسه اول (==)، مقدار‌های دو متغیر برابر هستند، بنابراین مقایسه موفق خواهد بود. اما در مقایسه دوم (===)، علاوه بر بررسی مقدار، نوع داده‌ها نیز بررسی می‌شود، بنابراین مقایسه ناموفق خواهد بود زیرا مقدار 5 (عدد) با '5' (رشته) هم‌مساوی نیست.</p>"
  },
  {
    "title": "2- تفاوت متدهای slice و splice ؟",
    "answer": "<p>متدهای slice و splice هر دو در جاوا اسکریپت برای کار با آرایه‌ها استفاده می‌شوند، اما کاربردها و عملکردهای آنها متفاوت است: <br /> <strong>slice(): </strong> برای ایجاد یک کپی از بخشی از آرایه استفاده می‌شود، بدون تغییر در آرایه اصلی. این متد دو پارامتر می‌پذیرد، شروع و پایان بخش مورد نظر برای کپی. این متد یک زیرآرایه از آرایه مبدا را برمی‌گرداند بدون تغییر در آرایه اصلی. نحوه استفاده: array.slice(start, end) <br /> <strong>splice(): </strong> برای تغییر محتوای یک آرایه استفاده می‌شود، از جمله حذف و یا اضافه کردن عناصر. این متد سه پارامتر می‌پذیرد، شروع، تعداد عناصری که می‌خواهید حذف کنید و هر عنصری که می‌خواهید به آرایه اضافه کنید. این متد عناصر حذف شده را برمی‌گرداند و آرایه اصلی را نیز تغییر می‌دهد.<br> نحوه استفاده: array.splice(start, deleteCount, item1, item2, ...) به عنوان مثال: <code> let array = [1, 2, 3, 4, 5]; <br /> // استفاده از slice <br /> let slicedArray = array.slice(1, 3); // [2, 3] <br /> console.log(array); // [1, 2, 3, 4, 5] (آرایه اصلی تغییر نمی‌کند) <br /> // استفاده از splice <br /> let splicedArray = array.splice(1, 2); // حذف [2, 3] <br /> console.log(array); // [1, 4, 5] (آرایه اصلی تغییر می‌کند) <br /> console.log(splicedArray); // [2, 3] (آرایه حذف شده) <br /> </code> بنابراین، تفاوت اصلی بین slice() و splice() این است که slice() یک زیرآرایه از آرایه اصلی را بدون تغییر آن برمی‌گرداند، در حالی که splice() عناصری را از آرایه اصلی حذف یا به آن اضافه می‌کند و آرایه اصلی را تغییر می‌دهد.</p>"
  },
  {
    "title": "3- تابع higher-order چیست ؟",
    "answer": "<p> تابع <strong>higher-order</strong> یک مفهوم مهم در برنامه‌نویسی است که به توابعی اشاره دارد که یا به عنوان آرگومان به یک تابع دیگر پاس داده می‌شوند یا از طریق بازگرداندن یک تابع به عنوان خروجی به عنوان نتیجه، تعامل بالاتری با توابع دیگر ایجاد می‌کنند. <br> به طور خاص، اگر یک تابع، یک تابع دیگر را به عنوان ورودی دریافت کند یا یک تابع را به عنوان خروجی برگرداند، به عنوان یک تابع Higher-Order شناخته می‌شود. این تابع‌ها به عنوان توابع اولیه (First-Class Functions) شناخته می‌شوند. <br> با استفاده از توابع Higher-Order، می‌توانید از انعطاف بیشتری در برنامه‌نویسی خود برخوردار شوید. این امکان را به شما می‌دهد که توابع را به عنوان داده‌هایی قابل انتقال مورد استفاده قرار دهید و از آنها برای ایجاد توابع پویا و چندمنظوره استفاده کنید. <br> <span>مثال‌هایی از توابع Higher-Order عبارتند از:</span> <br> <small> (Callback Functions):</small> ارسال تابع به عنوان یک پارامتر به یک تابع دیگر و استفاده از آن در زمانی که شرایط خاصی برآورده شود، مانند رویدادها در محیط وب. <br> <small> (Higher-Order Functions):</small> تابعی که یک تابع دیگر را به عنوان ورودی دریافت می‌کند و یک تابع جدید را به عنوان خروجی برمی‌گرداند، مانند map، filter و reduce در جاوااسکریپت. <br> <small> (Closure Functions):</small> توابعی که یک تابع را به عنوان ورودی دریافت می‌کنند و متغیرهای محلی خود را در یک محیط بسته (closure) ذخیره می‌کنند. <br> استفاده از توابع Higher-Order می‌تواند کد را خواناتر، ساده‌تر و قابل تعمیرتر کند و اجازه می‌دهد که برنامه‌ها به صورت مؤثر و قابل اطمینان اجرا شوند. <br> تابعی که یک تابع را به عنوان ورودی می‌پذیرد: <code> function operate(func, x, y) { return func(x, y); } <br> function add(a, b) { return a + b; } <br> function multiply(a, b) { return a * b; } <br> console.log(operate(add, 2, 3)); // 5 <br> console.log(operate(multiply, 2, 3)); // 6 </code> تابعی که یک تابع را به عنوان خروجی برمی‌گرداند: <br><code> function multiplier(factor) { return function(x) { return x * factor; }; } <br> let double = multiplier(2); <br> console.log(double(5)); // 10 <br> let triple = multiplier(3); <br> console.log(triple(5)); // 15 </code> Callback functions (توابع بازخوانی): <br><code> function processArray(arr, callback) { let result = []; for (let item of arr) { result.push(callback(item)); } return result; } <br> let numbers = [1, 2, 3, 4, 5]; <br> function square(x) { return x * x; } <br> let squaredNumbers = processArray(numbers, square); br console.log(squaredNumbers); // [1, 4, 9, 16, 25] </code></p>"
  },
  {
    "title": "4- تفاوت let و const و var ؟",
    "answer": "<p> تفاوت بین let، const و var در جاوا اسکریپت به روش تعریف و محدودیت تغییرپذیری متغیرها مربوط می‌شود. در اینجا تفاوت‌های اصلی آنها را بررسی می‌کنیم: <br /><strong>var :</strong> در ES5 معرفی شده است و قبل از اینکه let و const معرفی شوند، برای تعریف متغیرها استفاده می‌شد. متغیرهای تعریف شده با var دارای scope بلوکی نیستند، به عبارت دیگر، در محدوده‌ی بلاک‌ها، تابع‌ها و حتی برخی موارد دیگر مانند حلقه‌های for، تغییر پذیرند. <br /> متغیرهای تعریف شده با var قابلیت hoisting دارند، به این معنی که متغیرها قبل از اینکه تعریف شوند، به بالای محدوده قابل دسترسی می‌شوند. متغیرهایی که با var تعریف می‌شوند، قابلیت تغییر مقدار را دارند. می‌توان یک متغیر با var را دوباره تعریف کرد بدون دریافت خطا (redeclaration). <br /><strong>let :</strong> در ES6 (یا ECMAScript 2015) معرفی شده است و از آن به عنوان جایگزین بهتر برای var استفاده می‌شود. متغیرهای تعریف شده با let دارای scope بلوکی هستند، به عبارت دیگر، محدوده دقیق‌تری دارند و معمولاً بهترین روش برای تعریف متغیرها است. <br /> متغیرهای تعریف شده با let قابلیت hoisting را ندارند، به این معنی که قبل از تعریف، به بالای محدوده قابل دسترسی نیستند. می‌توان مقدار متغیرهای let را تغییر داد، یعنی این متغیرها می‌توانند reassigned شوند. امکان تعریف مجدد یک متغیر با let وجود ندارد، اگر دوباره تعریف شود، خطا ایجاد می‌شود. <br /><strong>const :</strong> نیز در ES6 معرفی شده است و برای تعریف ثابت‌ها (متغیرهایی که مقدار آنها بعد از تعریف تغییر نمی‌کند) استفاده می‌شود. متغیرهای تعریف شده با const نیاز به مقدار اولیه دارند و مقدار آنها نمی‌تواند پس از تعریف تغییر کند. مانند let، متغیرهای تعریف شده با const دارای scope بلوکی هستند. <br /> متغیرهای تعریف شده با const قابلیت hoisting را ندارند. اگر متغیری با const یک شیء یا یک آرایه را مشخص کند، می‌توان ویژگی‌های شیء یا مقادیر آرایه را تغییر داد، اما نمی‌توان متغیر خود را reassigned کرد. <code> var x = 10;<br> let y = 20;<br> const z = 30;<br> x = 15; // متغیر x را می‌توان تغییر داد<br> y = 25; // متغیر y را می‌توان تغییر داد<br> // z = 35; // خطا! مقدار متغیر const نمی‌تواند تغییر کند<br> var x = 5; // دوباره تعریف متغیر x با var ممکن است<br> // let y = 10; // خطا! تعریف مجدد متغیر با let ممکن نیست<br> // const z = 15; // خطا! تعریف مجدد متغیر const ممکن نیست<br> </code> بنابراین، استفاده از let و const به عنوان جایگزینی برای var توصیه می‌شود، زیرا آنها دارای scope بلوکی هستند و امکاناتی را برای ایجاد کد بهتر و امن‌تر فراهم می‌کنند. </p>"
  },
  {
    "title": "5- Hoisting در جاوااسکریپت ؟",
    "answer": "<p><strong>Hoisting</strong> به این معنی است که در جاوااسکریپت، تعریف متغیرها و توابع به صورت خودکار به بالای محدوده ای که در آن قرار دارند (یا به بالای کد محلی یا به بالای کد یک تابع) منتقل می‌شوند، به عبارت دیگر، متغیرها و توابعی که با استفاده از var تعریف می‌شوند، قبل از اجرای کد به بالای اسکوپ مربوطه منتقل می‌شوند. به طور دقیق‌تر، هنگامی که یک متغیر یا تابع با var تعریف می‌شود، جاوا اسکریپت در فاز کامپایل کد (قبل از اجرای آن) این تعاریف را به بالای اسکوپ مربوطه منتقل می‌کند. اما مقادیر این متغیرها در همان مکانی که از آنها استفاده می‌شود، نیستند؛ بلکه مقدار اولیه آنها در زمان اجرای کد تخصیص داده می‌شود. <br /> برای مثال: <code> console.log(x); // undefined <br> var x = 10;<br> console.log(x); // 10 <br> console.log(y()); // 'Hello, World!' <br> function y() { return 'Hello, World!'; } </code> در این مثال، اگرچه تعریف متغیر x پس از استفاده از آن (در خط اول) است، اما به دلیل hoisting، متغیر x به بالای اسکوپ منتقل شده و console.log(x) بدون خطا اجرا می‌شود. اما در زمان اجرا، مقدار x هنوز تعیین نشده است و به همین دلیل undefined چاپ می‌شود. سپس مقدار 10 به x تخصیص داده می‌شود و در خط سوم، console.log(x) مقدار 10 را چاپ می‌کند و همچنین تابع y به‌ صورت صحیح اجرا می شود. <br> به عنوان یک نکته، hoisting فقط برای تعریف‌هایی که با var صورت می‌گیرد اعمال می‌شود و برای تعریف‌هایی که با let یا const انجام می‌شود، این رفتار صورت نمی‌گیرد. این تفاوت مهمی است که بهبودی در ایمنی و قابلیت خوانایی کد ایجاد می‌کند.</p>"
  },
  {
    "title": "6- تفاوتهای بین cookie و local-storage و session-storage ؟",
    "answer": "<p>تمام این سه روش ذخیره‌سازی اطلاعات در مرورگرهای وب مورد استفاده قرار می‌گیرند، اما تفاوت‌های مهمی در عملکرد و کاربردهای آنها وجود دارد: <br /> <strong>Cookie :</strong><br /> یک روش ذخیره‌سازی اطلاعات در مرورگر است که بین سرور و مرورگر به صورت رشته‌های کوچک ارسال می‌شود. <br /> حداکثر حجم ذخیره‌سازی آن محدود به ۴KB است.<br /> همراه با هر درخواست به سرور ارسال می‌شود، این موجب می‌شود که مقدار زیادی از ترافیک شبکه اضافی به وجود آید.<br /> اطلاعات می‌تواند تا زمان انقضای مشخص شده باقی بماند یا تا زمانی که کاربر آن را پاک کند.<br /> <strong>localStorage :</strong><br /> یک فضای ذخیره‌سازی پایدار در مرورگر است که اطلاعات در آن به صورت کلید/مقدار (key/value) ذخیره می‌شوند. <br /> معمولاً حداکثر ۵MB حجم ذخیره‌سازی را دارا می‌باشد.<br /> اطلاعات موجود در localStorage تا زمانی که کاربر آن را پاک نکند، ثابت باقی می‌ماند.<br /> اطلاعات در localStorage از طریق JavaScript قابل دسترسی و تغییر هستند.<br /> اطلاعات در Local Storage توسط وب سایت‌های دیگر دیده نمی‌شوند و تنها توسط وب سایتی که آنها را ذخیره کرده است قابل دسترسی هستند.<br /> برای ذخیره اطلاعاتی که برای محلی بودن داده‌ها نیاز است و به سرور ارسال نمی‌شوند مفید است، مانند تنظیمات کاربر و داده‌های سمت کلاینت.<br /> <strong>sessionStorage :</strong><br>  مشابه localStorage عمل می‌کند، اما اطلاعات ذخیره شده در آن تنها برای جلسه فعلی مرورگر (یا تب) معتبر است و پس از بسته شدن تب، اطلاعات حذف می‌شوند. <br> همچنین معمولاً حداکثر ۵MB حجم ذخیره‌سازی را دارا می‌باشد.<br> برای اطلاعات موقتی که نیاز به حذف شدن پس از پایان یک نشست دارند مناسب است، مانند اطلاعات فرم موقت یا موقعیت کاربر در یک نشست.<br> اگر نیاز به ذخیره داده‌ها بین جلسات مرورگر داشته باشید و این داده‌ها باید با هر درخواست به سرور ارسال شوند، از cookie استفاده کنید. اگر نیاز به ذخیره داده‌ها برای مدت زمان بیشتری باشد و می‌خواهید اطلاعات پس از بسته شدن تب فعلی مرورگر نیز باقی بمانند، از localStorage استفاده کنید. اگر نیاز به ذخیره داده‌ها تنها برای جلسه فعلی مرورگر باشد، از sessionStorage استفاده کنید.<br> به طور خلاصه، کوکی‌ها برای اطلاعات کوچک و مرتبط با کاربر، Local Storage برای داده‌های بزرگتر و دائمی و Session Storage برای داده‌های موقت و مرتبط با جلسه استفاده می‌شوند.</p>"
  },
  {
    "title": "7- closure چیست ؟",
    "answer": "<p><strong>Closure :</strong> یکی از مفاهیم مهم در جاوااسکریپت است که در برنامه‌نویسی مدرن بسیار استفاده می‌شود. به طور کلی، Closure به معنای این است که یک تابع داخلی (inner function) به داده‌ها و متغیرهای محیط خارجی خود دسترسی دارد، حتی بعد از اینکه تابع خارجی (outer function) اجرا شده باشد و اجرای آن به پایان رسیده باشد. <br /> به عبارت دیگر، یک Closure شامل یک تابع داخلی است که به متغیرها و پارامترهای تابع خارجی خود دسترسی دارد. این تابع داخلی می‌تواند این متغیرها را برای محاسبه یا انجام عملیات دیگر استفاده کند و حتی پس از اتمام اجرای تابع خارجی، دسترسی به این متغیرها را داشته باشد. <br /> استفاده از Closure به ما امکان می‌دهد تا محیط محلی تابع را حفظ کرده و از متغیرها و اطلاعات موجود در آنها برای استفاده در توابع داخلی بهره ببریم، بدون اینکه نگرانی داشته باشیم که این اطلاعات با اتمام اجرای تابع خارجی از بین برود. <br /> یک مثال ساده از Closure در جاوااسکریپت: <br /><code> function outerFunction() {<br> let outerVariable = 'I am outer!';<br> function innerFunction() {<br> console.log(outerVariable); // دسترسی به متغیر بیرونی<br> } <br> return innerFunction;<br> } <br> let closure = outerFunction();<br> closure(); // اجرای تابع داخلی با استفاده از کلوژر </code> در این مثال، تابع innerFunction دارای دسترسی به متغیر outerVariable از تابع outerFunction است، حتی پس از اینکه outerFunction به پایان رسیده است. این امر به وجود کلوژر برمی‌گردد که innerFunction توانایی دسترسی به متغیرها و پارامترهای outerFunction را فراهم می‌کند، از جمله پس از اجرای outerFunction. <br> مزیت اصلی کلوژر در این است که توانایی ایجاد محیط‌های داده از قبل معین شده و انتقال متغیرها و اطلاعات بین توابع را فراهم می‌کند، بدون اینکه این اطلاعات به صورت عمومی در دسترس دیگر بخش‌های برنامه باشند. این امر امکان ایجاد کدی بسیار منظمتر و قابل تعمیم را فراهم می‌کند.</p>"
  },
  {
    "title": "8- Module چیست ؟",
    "answer": "<p><strong>ماژول‌ها (Modules) :</strong>در جاوا اسکریپت به شیوه‌ای برای تقسیم برنامه به بخش‌های کوچک‌تر و مدیریت کد بهتر کمک می‌کنند. مفهوم ماژول در جاوا اسکریپت به صورت رسمی در استاندارد ECMAScript 2015 (معروف به ES6) معرفی شد و ابزارهای مختلفی برای استفاده از ماژول‌ها در جاوا اسکریپت وجود دارد، از جمله وارد کردن و صادر کردن ماژول‌ها با استفاده از import و export. <br /> <span>مزایای استفاده از ماژول‌ها عبارتند از: </span><br /> <small>سازماندهی بهتر کد:</small> ماژول‌ها به تقسیم بندی کد به بخش‌های کوچکتر کمک می‌کنند که به راحتی قابل مدیریت و توسعه هستند. <br /> <small>رفع تداخل نام:</small> ماژول‌ها به صورت مستقل از یکدیگر عمل می‌کنند، بنابراین از تداخل نام‌ها در متغیرها و توابع در سطح سراسری برنامه جلوگیری می‌کنند. <br /> <small>قابلیت استفاده مجدد (Reusability):</small> با استفاده از ماژول‌ها، می‌توانید کد را به شکل مستقلی ایجاد کنید که بعداً در پروژه‌های دیگر قابل استفاده باشد. <br /> ماژول‌ها می‌توانند توابع، کلاس‌ها، متغیرها و سایر اجزای کد را شامل شوند و معمولاً یک فایل جداگانه برای هر ماژول ایجاد می‌شود. سپس ماژول‌ها را می‌توان با استفاده از import و export در دیگر فایل‌ها به کار برد. این کار امکان ایجاد برنامه‌های بزرگتر و پیچیده‌تر را با کدی که بهبود یافته و بهتر سازماندهی شده است، فراهم می‌کند.</p>"
  },
  {
    "title": "9- مفهوم Asynchronous جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، اجرای کد به صورت همزمان (Synchronous) و غیرهمزمان (Asynchronous) اتفاق می‌افتد. <br> در جاوا اسکریپت، مفهوم Asynchronous به استفاده از کدهایی اشاره دارد که اجرای آنها به صورت همزمان با سایر عملیات‌ها انجام می‌شود، بدون اینکه انتظار برای اتمام آن عملیات‌ها وجود داشته باشد. به عبارت دیگر، اجرای کدها به صورت غیرهمزمان انجام می‌شود. <br> استفاده از کدهای غیرهمزمان مفید است زمانی که برنامه نیاز به انجام عملیات‌هایی دارد که ممکن است زمان زیادی طول بکشد، مانند خواندن اطلاعات از پایگاه داده، درخواست اطلاعات از سرور، یا اجرای عملیات‌های پرهزینه محاسباتی. در این صورت، به جای انتظار برای اتمام این عملیات‌ها، برنامه می‌تواند به سایر کدهای خود ادامه دهد و بعداً به نتیجه این عملیات‌ها بازگردد. <br> برای ایجاد عملیات غیرهمزمان در جاوا اسکریپت، از مکانیزم‌هایی مانند Callbacks، Promises، و Async/Await استفاده می‌شود. این مکانیزم‌ها به برنامه امکان اجرای عملیات‌های غیرهمزمان و مدیریت بهتر جریان کد را می‌دهند، این مکانیسم‌ها به برنامه‌نویس اجازه می‌دهند که به صورت راحت‌تر با اجراهای Asynchronous کار کنند و کد را به شکلی خوانا و قابل نگهداری تر بنویسند.</p>"
  },
  {
    "title": "10- Promise چیست و چرا به آن نیاز داریم ؟",
    "answer": "<p><strong>Promise :</strong> در جاوااسکریپت یک الگوی برنامه‌نویسی است که برای مدیریت عملیات‌های ناهمگام (Asynchronous) استفاده می‌شود. یک Promise یک شیء قابل انتظار است که نتیجه یک عملیات ناهمگام را نشان می‌دهد، می‌تواند مقدار یا خطا باشد. Promise به برنامه‌نویس اجازه می‌دهد که با عملیاتی که طول می‌کشد به صورت بهتر و قابل پیش‌بینی‌تر برخورد کند. <br /> <span>مزایای استفاده از Promise عبارتند از:</span> <br /> <small>مدیریت اجراهای ناهمگام:</small> با استفاده از Promise، می‌توانیم به راحتی با اجراهای ناهمگام کار کنیم، مانند درخواست‌های شبکه، خواندن و نوشتن فایل‌ها، و دسترسی به پایگاه داده. <br /> <small>کد خوانا:</small> Promise اجازه می‌دهد که کد نوشته شده برای اجراهای ناهمگام قابل خواندن‌تر و قابل نگهداری‌تر باشد. با استفاده از زنجیره‌ای از then و catch، می‌توان کد را به صورت ساختار یافته‌تری نوشت و اشکالات راحت‌تر پیدا کرد. <br /> <small>مدیریت خطا:</small> Promise امکان مدیریت خطاها را فراهم می‌کند. با استفاده از catch، می‌توانیم خطاهایی که در طول اجرای Promise رخ می‌دهند را به صورت مرتب و منظم مدیریت کنیم. <br /> <span>یک Promise می‌تواند در یکی از سه حالت از نظر وضعیت باشد:</span> <br /> <small>Pending:</small> وضعیت اولیه که هنگامی که Promise ایجاد شده است، از این حالت شروع می‌شود.<br /> <small>Fulfilled (Resolved):</small> وضعیتی که Promise با موفقیت اجرا شده و مقدار خروجی مورد انتظار تولید شده است.<br /> <small>Rejected:</small> وضعیتی که Promise به دلیل خطا یا شرایط نامطلوب دیگر نتوانست مقدار مورد انتظار را تولید کند.<br /> به طور کلی، Promise به برنامه‌نویس اجازه می‌دهد تا با راحتی و انعطاف بیشتری عملیات‌های ناهمگام را مدیریت کند و به کدی تمیزتر و خواناتر دست پیدا کند. این بهبود در ساختار و قابلیت‌های برنامه‌نویسی به معنایی بهتر و کارایی بیشتر برنامه می‌باشد.</p>"
  }
]
