[
  {
    "title": "1- تفاوت عملگرهای == و === ؟",
    "answer": "<p>عملگرهای == و === در جاوااسکریپت برای مقایسه مقادیر استفاده می‌شوند، اما تفاوت اصلی بین آنها در نحوه انجام مقایسه و نوع داده‌هایی که توانایی مقایسه آنها را دارند است <br /> <strong> == :</strong> این عملگر برای مقایسه مقادیر استفاده می‌شود. زمانی که از این عملگر استفاده می‌کنید، داده‌ها را با توجه به مقدار آنها مقایسه می‌کند. اگر مقادیر دو متغیر یکسان باشند، مقایسه موفق خواهد بود. <br /> <strong> === :</strong> این عملگر نیز برای مقایسه مقادیر استفاده می‌شود، اما با این تفاوت که علاوه بر مقایسه مقادیر، نوع داده‌ها نیز بررسی می‌شود. اگر دو مقدار نه تنها مساوی باشند بلکه همچنین نوع داده‌های آنها نیز یکسان باشد، مقایسه با === موفق خواهد بود. این عملگر به عنوان 'مقایسه دقیق' شناخته می‌شود. <br /> به عنوان مثال: <code> console.log(5 == '5'); // true <br /> console.log(5 === '5'); // false </code> در مثال بالا، در مقایسه اول (==)، مقدار‌های دو متغیر برابر هستند، بنابراین مقایسه موفق خواهد بود. اما در مقایسه دوم (===)، علاوه بر بررسی مقدار، نوع داده‌ها نیز بررسی می‌شود، بنابراین مقایسه ناموفق خواهد بود زیرا مقدار 5 (عدد) با '5' (رشته) هم‌مساوی نیست.</p>"
  },
  {
    "title": "2- تفاوت متدهای slice و splice ؟",
    "answer": "<p>متدهای slice و splice هر دو در جاوا اسکریپت برای کار با آرایه‌ها استفاده می‌شوند، اما کاربردها و عملکردهای آنها متفاوت است: <br /> <strong>slice(): </strong> برای ایجاد یک کپی از بخشی از آرایه استفاده می‌شود، بدون تغییر در آرایه اصلی. این متد دو پارامتر می‌پذیرد، شروع و پایان بخش مورد نظر برای کپی. این متد یک زیرآرایه از آرایه مبدا را برمی‌گرداند بدون تغییر در آرایه اصلی. نحوه استفاده: array.slice(start, end) <br /> <strong>splice(): </strong> برای تغییر محتوای یک آرایه استفاده می‌شود، از جمله حذف و یا اضافه کردن عناصر. این متد سه پارامتر می‌پذیرد، شروع، تعداد عناصری که می‌خواهید حذف کنید و هر عنصری که می‌خواهید به آرایه اضافه کنید. این متد عناصر حذف شده را برمی‌گرداند و آرایه اصلی را نیز تغییر می‌دهد.<br> نحوه استفاده: array.splice(start, deleteCount, item1, item2, ...) به عنوان مثال: <code> let array = [1, 2, 3, 4, 5]; <br /> // استفاده از slice <br /> let slicedArray = array.slice(1, 3); // [2, 3] <br /> console.log(array); // [1, 2, 3, 4, 5] (آرایه اصلی تغییر نمی‌کند) <br /> // استفاده از splice <br /> let splicedArray = array.splice(1, 2); // حذف [2, 3] <br /> console.log(array); // [1, 4, 5] (آرایه اصلی تغییر می‌کند) <br /> console.log(splicedArray); // [2, 3] (آرایه حذف شده) <br /> </code> بنابراین، تفاوت اصلی بین slice() و splice() این است که slice() یک زیرآرایه از آرایه اصلی را بدون تغییر آن برمی‌گرداند، در حالی که splice() عناصری را از آرایه اصلی حذف یا به آن اضافه می‌کند و آرایه اصلی را تغییر می‌دهد.</p>"
  },
  {
    "title": "3- تابع higher-order چیست ؟",
    "answer": "<p> تابع <strong>higher-order</strong> یک مفهوم مهم در برنامه‌نویسی است که به توابعی اشاره دارد که یا به عنوان آرگومان به یک تابع دیگر پاس داده می‌شوند یا از طریق بازگرداندن یک تابع به عنوان خروجی به عنوان نتیجه، تعامل بالاتری با توابع دیگر ایجاد می‌کنند. <br> به طور خاص، اگر یک تابع، یک تابع دیگر را به عنوان ورودی دریافت کند یا یک تابع را به عنوان خروجی برگرداند، به عنوان یک تابع Higher-Order شناخته می‌شود. این تابع‌ها به عنوان توابع اولیه (First-Class Functions) شناخته می‌شوند. <br> با استفاده از توابع Higher-Order، می‌توانید از انعطاف بیشتری در برنامه‌نویسی خود برخوردار شوید. این امکان را به شما می‌دهد که توابع را به عنوان داده‌هایی قابل انتقال مورد استفاده قرار دهید و از آنها برای ایجاد توابع پویا و چندمنظوره استفاده کنید. <br> <span>مثال‌هایی از توابع Higher-Order عبارتند از:</span> <br> <small> (Callback Functions):</small> ارسال تابع به عنوان یک پارامتر به یک تابع دیگر و استفاده از آن در زمانی که شرایط خاصی برآورده شود، مانند رویدادها در محیط وب. <br> <small> (Higher-Order Functions):</small> تابعی که یک تابع دیگر را به عنوان ورودی دریافت می‌کند و یک تابع جدید را به عنوان خروجی برمی‌گرداند، مانند map، filter و reduce در جاوااسکریپت. <br> <small> (Closure Functions):</small> توابعی که یک تابع را به عنوان ورودی دریافت می‌کنند و متغیرهای محلی خود را در یک محیط بسته (closure) ذخیره می‌کنند. <br> استفاده از توابع Higher-Order می‌تواند کد را خواناتر، ساده‌تر و قابل تعمیرتر کند و اجازه می‌دهد که برنامه‌ها به صورت مؤثر و قابل اطمینان اجرا شوند. <br> تابعی که یک تابع را به عنوان ورودی می‌پذیرد: <code> function operate(func, x, y) { return func(x, y); } <br> function add(a, b) { return a + b; } <br> function multiply(a, b) { return a * b; } <br> console.log(operate(add, 2, 3)); // 5 <br> console.log(operate(multiply, 2, 3)); // 6 </code> تابعی که یک تابع را به عنوان خروجی برمی‌گرداند: <br><code> function multiplier(factor) { return function(x) { return x * factor; }; } <br> let double = multiplier(2); <br> console.log(double(5)); // 10 <br> let triple = multiplier(3); <br> console.log(triple(5)); // 15 </code> Callback functions (توابع بازخوانی): <br><code> function processArray(arr, callback) { let result = []; for (let item of arr) { result.push(callback(item)); } return result; } <br> let numbers = [1, 2, 3, 4, 5]; <br> function square(x) { return x * x; } <br> let squaredNumbers = processArray(numbers, square); br console.log(squaredNumbers); // [1, 4, 9, 16, 25] </code></p>"
  },
  {
    "title": "4- تفاوت let و const و var ؟",
    "answer": "<p> تفاوت بین let، const و var در جاوا اسکریپت به روش تعریف و محدودیت تغییرپذیری متغیرها مربوط می‌شود. در اینجا تفاوت‌های اصلی آنها را بررسی می‌کنیم: <br /><strong>var :</strong> در ES5 معرفی شده است و قبل از اینکه let و const معرفی شوند، برای تعریف متغیرها استفاده می‌شد. متغیرهای تعریف شده با var دارای scope بلوکی نیستند، به عبارت دیگر، در محدوده‌ی بلاک‌ها، تابع‌ها و حتی برخی موارد دیگر مانند حلقه‌های for، تغییر پذیرند. <br /> متغیرهای تعریف شده با var قابلیت hoisting دارند، به این معنی که متغیرها قبل از اینکه تعریف شوند، به بالای محدوده قابل دسترسی می‌شوند. متغیرهایی که با var تعریف می‌شوند، قابلیت تغییر مقدار را دارند. می‌توان یک متغیر با var را دوباره تعریف کرد بدون دریافت خطا (redeclaration). <br /><strong>let :</strong> در ES6 (یا ECMAScript 2015) معرفی شده است و از آن به عنوان جایگزین بهتر برای var استفاده می‌شود. متغیرهای تعریف شده با let دارای scope بلوکی هستند، به عبارت دیگر، محدوده دقیق‌تری دارند و معمولاً بهترین روش برای تعریف متغیرها است. <br /> متغیرهای تعریف شده با let قابلیت hoisting را ندارند، به این معنی که قبل از تعریف، به بالای محدوده قابل دسترسی نیستند. می‌توان مقدار متغیرهای let را تغییر داد، یعنی این متغیرها می‌توانند reassigned شوند. امکان تعریف مجدد یک متغیر با let وجود ندارد، اگر دوباره تعریف شود، خطا ایجاد می‌شود. <br /><strong>const :</strong> نیز در ES6 معرفی شده است و برای تعریف ثابت‌ها (متغیرهایی که مقدار آنها بعد از تعریف تغییر نمی‌کند) استفاده می‌شود. متغیرهای تعریف شده با const نیاز به مقدار اولیه دارند و مقدار آنها نمی‌تواند پس از تعریف تغییر کند. مانند let، متغیرهای تعریف شده با const دارای scope بلوکی هستند. <br /> متغیرهای تعریف شده با const قابلیت hoisting را ندارند. اگر متغیری با const یک شیء یا یک آرایه را مشخص کند، می‌توان ویژگی‌های شیء یا مقادیر آرایه را تغییر داد، اما نمی‌توان متغیر خود را reassigned کرد. <code> var x = 10;<br> let y = 20;<br> const z = 30;<br> x = 15; // متغیر x را می‌توان تغییر داد<br> y = 25; // متغیر y را می‌توان تغییر داد<br> // z = 35; // خطا! مقدار متغیر const نمی‌تواند تغییر کند<br> var x = 5; // دوباره تعریف متغیر x با var ممکن است<br> // let y = 10; // خطا! تعریف مجدد متغیر با let ممکن نیست<br> // const z = 15; // خطا! تعریف مجدد متغیر const ممکن نیست<br> </code> بنابراین، استفاده از let و const به عنوان جایگزینی برای var توصیه می‌شود، زیرا آنها دارای scope بلوکی هستند و امکاناتی را برای ایجاد کد بهتر و امن‌تر فراهم می‌کنند. </p>"
  },
  {
    "title": "5- hoisting در جاوااسکریپت ؟",
    "answer": "<p><strong>Hoisting</strong> به این معنی است که در جاوااسکریپت، تعریف متغیرها و توابع به صورت خودکار به بالای محدوده ای که در آن قرار دارند (یا به بالای کد محلی یا به بالای کد یک تابع) منتقل می‌شوند، به عبارت دیگر، متغیرها و توابعی که با استفاده از var تعریف می‌شوند، قبل از اجرای کد به بالای اسکوپ مربوطه منتقل می‌شوند. به طور دقیق‌تر، هنگامی که یک متغیر یا تابع با var تعریف می‌شود، جاوا اسکریپت در فاز کامپایل کد (قبل از اجرای آن) این تعاریف را به بالای اسکوپ مربوطه منتقل می‌کند. اما مقادیر این متغیرها در همان مکانی که از آنها استفاده می‌شود، نیستند؛ بلکه مقدار اولیه آنها در زمان اجرای کد تخصیص داده می‌شود. <br /> برای مثال: <code> console.log(x); // undefined <br> var x = 10;<br> console.log(x); // 10 <br> console.log(y()); // 'Hello, World!' <br> function y() { return 'Hello, World!'; } </code> در این مثال، اگرچه تعریف متغیر x پس از استفاده از آن (در خط اول) است، اما به دلیل hoisting، متغیر x به بالای اسکوپ منتقل شده و console.log(x) بدون خطا اجرا می‌شود. اما در زمان اجرا، مقدار x هنوز تعیین نشده است و به همین دلیل undefined چاپ می‌شود. سپس مقدار 10 به x تخصیص داده می‌شود و در خط سوم، console.log(x) مقدار 10 را چاپ می‌کند و همچنین تابع y به‌ صورت صحیح اجرا می شود. <br> به عنوان یک نکته، hoisting فقط برای تعریف‌هایی که با var صورت می‌گیرد اعمال می‌شود و برای تعریف‌هایی که با let یا const انجام می‌شود، این رفتار صورت نمی‌گیرد. این تفاوت مهمی است که بهبودی در ایمنی و قابلیت خوانایی کد ایجاد می‌کند.</p>"
  },
  {
    "title": "6- تفاوت cookie و local-storage و session-storage ؟",
    "answer": "<p>تمام این سه روش ذخیره‌سازی اطلاعات در مرورگرهای وب مورد استفاده قرار می‌گیرند، اما تفاوت‌های مهمی در عملکرد و کاربردهای آنها وجود دارد: <br /> <strong>Cookie :</strong><br /> یک روش ذخیره‌سازی اطلاعات در مرورگر است که بین سرور و مرورگر به صورت رشته‌های کوچک ارسال می‌شود. <br /> حداکثر حجم ذخیره‌سازی آن محدود به ۴KB است.<br /> همراه با هر درخواست به سرور ارسال می‌شود، این موجب می‌شود که مقدار زیادی از ترافیک شبکه اضافی به وجود آید.<br /> اطلاعات می‌تواند تا زمان انقضای مشخص شده باقی بماند یا تا زمانی که کاربر آن را پاک کند.<br /> <strong>localStorage :</strong><br /> یک فضای ذخیره‌سازی پایدار در مرورگر است که اطلاعات در آن به صورت کلید/مقدار (key/value) ذخیره می‌شوند. <br /> معمولاً حداکثر ۵MB حجم ذخیره‌سازی را دارا می‌باشد.<br /> اطلاعات موجود در localStorage تا زمانی که کاربر آن را پاک نکند، ثابت باقی می‌ماند.<br /> اطلاعات در localStorage از طریق JavaScript قابل دسترسی و تغییر هستند.<br /> اطلاعات در Local Storage توسط وب سایت‌های دیگر دیده نمی‌شوند و تنها توسط وب سایتی که آنها را ذخیره کرده است قابل دسترسی هستند.<br /> برای ذخیره اطلاعاتی که برای محلی بودن داده‌ها نیاز است و به سرور ارسال نمی‌شوند مفید است، مانند تنظیمات کاربر و داده‌های سمت کلاینت.<br /> <strong>sessionStorage :</strong><br>  مشابه localStorage عمل می‌کند، اما اطلاعات ذخیره شده در آن تنها برای جلسه فعلی مرورگر (یا تب) معتبر است و پس از بسته شدن تب، اطلاعات حذف می‌شوند. <br> همچنین معمولاً حداکثر ۵MB حجم ذخیره‌سازی را دارا می‌باشد.<br> برای اطلاعات موقتی که نیاز به حذف شدن پس از پایان یک نشست دارند مناسب است، مانند اطلاعات فرم موقت یا موقعیت کاربر در یک نشست.<br> اگر نیاز به ذخیره داده‌ها بین جلسات مرورگر داشته باشید و این داده‌ها باید با هر درخواست به سرور ارسال شوند، از cookie استفاده کنید. اگر نیاز به ذخیره داده‌ها برای مدت زمان بیشتری باشد و می‌خواهید اطلاعات پس از بسته شدن تب فعلی مرورگر نیز باقی بمانند، از localStorage استفاده کنید. اگر نیاز به ذخیره داده‌ها تنها برای جلسه فعلی مرورگر باشد، از sessionStorage استفاده کنید.<br> به طور خلاصه، کوکی‌ها برای اطلاعات کوچک و مرتبط با کاربر، Local Storage برای داده‌های بزرگتر و دائمی و Session Storage برای داده‌های موقت و مرتبط با جلسه استفاده می‌شوند.</p>"
  },
  {
    "title": "7- closure چیست ؟",
    "answer": "<p><strong>Closure :</strong> یکی از مفاهیم مهم در جاوااسکریپت است که در برنامه‌نویسی مدرن بسیار استفاده می‌شود. به طور کلی، Closure به معنای این است که یک تابع داخلی (inner function) به داده‌ها و متغیرهای محیط خارجی خود دسترسی دارد، حتی بعد از اینکه تابع خارجی (outer function) اجرا شده باشد و اجرای آن به پایان رسیده باشد. <br /> به عبارت دیگر، یک Closure شامل یک تابع داخلی است که به متغیرها و پارامترهای تابع خارجی خود دسترسی دارد. این تابع داخلی می‌تواند این متغیرها را برای محاسبه یا انجام عملیات دیگر استفاده کند و حتی پس از اتمام اجرای تابع خارجی، دسترسی به این متغیرها را داشته باشد. <br /> استفاده از Closure به ما امکان می‌دهد تا محیط محلی تابع را حفظ کرده و از متغیرها و اطلاعات موجود در آنها برای استفاده در توابع داخلی بهره ببریم، بدون اینکه نگرانی داشته باشیم که این اطلاعات با اتمام اجرای تابع خارجی از بین برود. <br /> یک مثال ساده از Closure در جاوااسکریپت: <br /><code> function outerFunction() {<br> let outerVariable = 'I am outer!';<br> function innerFunction() {<br> console.log(outerVariable); // دسترسی به متغیر بیرونی<br> } <br> return innerFunction;<br> } <br> let closure = outerFunction();<br> closure(); // اجرای تابع داخلی با استفاده از کلوژر </code> در این مثال، تابع innerFunction دارای دسترسی به متغیر outerVariable از تابع outerFunction است، حتی پس از اینکه outerFunction به پایان رسیده است. این امر به وجود کلوژر برمی‌گردد که innerFunction توانایی دسترسی به متغیرها و پارامترهای outerFunction را فراهم می‌کند، از جمله پس از اجرای outerFunction. <br> مزیت اصلی کلوژر در این است که توانایی ایجاد محیط‌های داده از قبل معین شده و انتقال متغیرها و اطلاعات بین توابع را فراهم می‌کند، بدون اینکه این اطلاعات به صورت عمومی در دسترس دیگر بخش‌های برنامه باشند. این امر امکان ایجاد کدی بسیار منظمتر و قابل تعمیم را فراهم می‌کند.</p>"
  },
  {
    "title": "8- module چیست ؟",
    "answer": "<p><strong>ماژول‌ها (Modules) :</strong>در جاوا اسکریپت به شیوه‌ای برای تقسیم برنامه به بخش‌های کوچک‌تر و مدیریت کد بهتر کمک می‌کنند. مفهوم ماژول در جاوا اسکریپت به صورت رسمی در استاندارد ECMAScript 2015 (معروف به ES6) معرفی شد و ابزارهای مختلفی برای استفاده از ماژول‌ها در جاوا اسکریپت وجود دارد، از جمله وارد کردن و صادر کردن ماژول‌ها با استفاده از import و export. <br /> <span>مزایای استفاده از ماژول‌ها عبارتند از: </span><br /> <small>سازماندهی بهتر کد:</small> ماژول‌ها به تقسیم بندی کد به بخش‌های کوچکتر کمک می‌کنند که به راحتی قابل مدیریت و توسعه هستند. <br /> <small>رفع تداخل نام:</small> ماژول‌ها به صورت مستقل از یکدیگر عمل می‌کنند، بنابراین از تداخل نام‌ها در متغیرها و توابع در سطح سراسری برنامه جلوگیری می‌کنند. <br /> <small>قابلیت استفاده مجدد (Reusability):</small> با استفاده از ماژول‌ها، می‌توانید کد را به شکل مستقلی ایجاد کنید که بعداً در پروژه‌های دیگر قابل استفاده باشد. <br /> ماژول‌ها می‌توانند توابع، کلاس‌ها، متغیرها و سایر اجزای کد را شامل شوند و معمولاً یک فایل جداگانه برای هر ماژول ایجاد می‌شود. سپس ماژول‌ها را می‌توان با استفاده از import و export در دیگر فایل‌ها به کار برد. این کار امکان ایجاد برنامه‌های بزرگتر و پیچیده‌تر را با کدی که بهبود یافته و بهتر سازماندهی شده است، فراهم می‌کند.</p>"
  },
  {
    "title": "9- مفهوم asynchronous جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، اجرای کد به صورت همزمان (Synchronous) و غیرهمزمان (Asynchronous) اتفاق می‌افتد. <br> در جاوا اسکریپت، مفهوم Asynchronous به استفاده از کدهایی اشاره دارد که اجرای آنها به صورت همزمان با سایر عملیات‌ها انجام می‌شود، بدون اینکه انتظار برای اتمام آن عملیات‌ها وجود داشته باشد. به عبارت دیگر، اجرای کدها به صورت غیرهمزمان انجام می‌شود. <br> استفاده از کدهای غیرهمزمان مفید است زمانی که برنامه نیاز به انجام عملیات‌هایی دارد که ممکن است زمان زیادی طول بکشد، مانند خواندن اطلاعات از پایگاه داده، درخواست اطلاعات از سرور، یا اجرای عملیات‌های پرهزینه محاسباتی. در این صورت، به جای انتظار برای اتمام این عملیات‌ها، برنامه می‌تواند به سایر کدهای خود ادامه دهد و بعداً به نتیجه این عملیات‌ها بازگردد. <br> برای ایجاد عملیات غیرهمزمان در جاوا اسکریپت، از مکانیزم‌هایی مانند Callbacks، Promises، و Async/Await استفاده می‌شود. این مکانیزم‌ها به برنامه امکان اجرای عملیات‌های غیرهمزمان و مدیریت بهتر جریان کد را می‌دهند، این مکانیسم‌ها به برنامه‌نویس اجازه می‌دهند که به صورت راحت‌تر با اجراهای Asynchronous کار کنند و کد را به شکلی خوانا و قابل نگهداری تر بنویسند.</p>"
  },
  {
    "title": "10- promise چیست و چرا به آن نیاز داریم ؟",
    "answer": "<p><strong>Promise :</strong> در جاوااسکریپت یک الگوی برنامه‌نویسی است که برای مدیریت عملیات‌های ناهمگام (Asynchronous) استفاده می‌شود. یک Promise یک شیء قابل انتظار است که نتیجه یک عملیات ناهمگام را نشان می‌دهد، می‌تواند مقدار یا خطا باشد. Promise به برنامه‌نویس اجازه می‌دهد که با عملیاتی که طول می‌کشد به صورت بهتر و قابل پیش‌بینی‌تر برخورد کند. <br /> <span>مزایای استفاده از Promise عبارتند از:</span> <br /> <small>مدیریت اجراهای ناهمگام:</small> با استفاده از Promise، می‌توانیم به راحتی با اجراهای ناهمگام کار کنیم، مانند درخواست‌های شبکه، خواندن و نوشتن فایل‌ها، و دسترسی به پایگاه داده. <br /> <small>کد خوانا:</small> Promise اجازه می‌دهد که کد نوشته شده برای اجراهای ناهمگام قابل خواندن‌تر و قابل نگهداری‌تر باشد. با استفاده از زنجیره‌ای از then و catch، می‌توان کد را به صورت ساختار یافته‌تری نوشت و اشکالات راحت‌تر پیدا کرد. <br /> <small>مدیریت خطا:</small> Promise امکان مدیریت خطاها را فراهم می‌کند. با استفاده از catch، می‌توانیم خطاهایی که در طول اجرای Promise رخ می‌دهند را به صورت مرتب و منظم مدیریت کنیم. <br /> <span>یک Promise می‌تواند در یکی از سه حالت از نظر وضعیت باشد:</span> <br /> <small>Pending:</small> وضعیت اولیه که هنگامی که Promise ایجاد شده است، از این حالت شروع می‌شود.<br /> <small>Fulfilled (Resolved):</small> وضعیتی که Promise با موفقیت اجرا شده و مقدار خروجی مورد انتظار تولید شده است.<br /> <small>Rejected:</small> وضعیتی که Promise به دلیل خطا یا شرایط نامطلوب دیگر نتوانست مقدار مورد انتظار را تولید کند.<br /> به طور کلی، Promise به برنامه‌نویس اجازه می‌دهد تا با راحتی و انعطاف بیشتری عملیات‌های ناهمگام را مدیریت کند و به کدی تمیزتر و خواناتر دست پیدا کند. این بهبود در ساختار و قابلیت‌های برنامه‌نویسی به معنایی بهتر و کارایی بیشتر برنامه می‌باشد.</p>"
  },
  {
    "title": "11- توابع callback - مزایا و معایب آن ؟",
    "answer": "<p><strong>توابع callback </strong> یک الگوی برنامه‌نویسی در جاوااسکریپت هستند که در اجراهای ناهمگام و همچنین در مواقعی که نیاز به اجرای کدی بعد از اتمام یک عملیات خاص داریم، استفاده می‌شوند. این توابع به عنوان پارامتر به توابع دیگر ارسال شده و بعد از اتمام عملیات مورد نظر، فراخوانی می‌شوند. در زیر مزایا و معایب استفاده از توابع callback آورده شده است.<br /> <span>مزایا :</span><br /> <small> مدیریت بهتر اجراهای ناهمگام :</small> Callback Functions اجازه می‌دهند تا کدهایی که باید بعد از اتمام یک عملیات ناهمگام اجرا شوند، به آسانی تعریف و مدیریت شوند. <br /> <small>کد قابل باز استفاده :</small>استفاده از توابع callback امکان استفاده مجدد از کدها را فراهم می‌کند، زیرا می‌توان یک تابع callback را به یک تابع دیگر ارسال کرد و همچنین توابع callback قابل استفاده مجدد هستند. <br /> <small>انعطاف‌پذیری بالا :</small> از آنجایی که توابع بازخوانی به عنوان پارامتر به توابع دیگر ارسال می‌شوند، این الگو انعطاف‌پذیری بالایی در استفاده از کدها را فراهم می‌کند و امکان تعویض عملکرد توابع را فراهم می‌کند. <br /> <span>معایب :</span><br /> <small>کد ناخوانا و پیچیده :</small>استفاده از توابع callback ممکن است منجر به کدی شود که دشوار قابل فهم و پیچیده باشد، به ویژه زمانی که بیش از یک تابع callback مورد استفاده قرار بگیرد و یا وابستگی‌های پیچیده‌ای ایجاد شود. <br /> <small>Callback Hell :</small>زمانی که توابع بازخوانی به صورت متوالی تو در تو قرار می‌گیرند، ممکن است در موقعیتی به نام 'Callback Hell' یا 'Pyramid of Doom' بیافتید که کد بسیار پیچیده و دشوار به خواندن و نگهداری است. <br /> <small>مدیریت خطا :</small>مدیریت خطا در توابع بازخوانی ممکن است دشوار باشد، زیرا خطاها ممکن است در توابع بازخوانی مختلف و به صورت غیر همزمان رخ دهند و باید با دقت مدیریت شوند. <br /> به طور کلی، توابع بازخوانی می‌توانند به عنوان یک الگوی برنامه‌نویسی کارا و مؤثر برای مدیریت اجراهای ناهمگام مورد استفاده قرار بگیرند، اما باید با معایب و محدودیت‌های آن آشنا باشید و از روش‌های بهتری مانند Promise یا Async/Await نیز استفاده کنید.</p>"
  },
  {
    "title": "12- کاربرد async/await ؟",
    "answer": "<p><strong>Async/Await</strong> یک ویژگی جدید در جاوااسکریپت است که با انتشار استاندارد ES2017 (یا ES8) معرفی شد. این ویژگی به برنامه‌نویسان اجازه می‌دهد تا به آسانی با اجراهای ناهمگام (Asynchronous) کار کنند و کدهایی را که به صورت متوالی اجرا می‌شوند به شکلی مانند کدهای همزمان نوشته شوند. <br /> <span>کاربردهای Async/Await عبارتند از :</span><br /> <small>سادگی خواندن کد: </small>Async/Await امکان نوشتن کدی را فراهم می‌کند که به صورت همزمان و مرتبط به نظر می‌رسد، بدون نیاز به توابع بازخوانی (Callback Functions) یا توابع Promise.then(). <br /> <small>مدیریت و پیگیری خطاها: </small>از آنجایی که Async/Await در واقع یک نوع شکل‌دهی به توابع Promise است، امکان مدیریت خطاها با استفاده از try/catch فراهم می‌شود، که کار با خطاها را آسان‌تر و خواناتر می‌کند. <br /> <small>پیگیری و استفاده از مقادیر بازگشتی: </small>از آنجایی که Async/Await به صورت مستقیم مقدار بازگشتی تابع Promise را به شکل همزمان فراهم می‌کند، این امکان فراهم می‌شود که مقادیر بازگشتی را بدون نیاز به زنجیره‌سازی توابع then() دستکاری و استفاده کنید. <br /> <small>کارایی و قابلیت انتقال: </small>Async/Await به برنامه‌نویس امکان می‌دهد که به سادگی بین توابع همگام و ناهمگام تغییر کند، بدون اینکه بخش‌های زیادی از کد را عوض کند. <br /> با استفاده از Async/Await، برنامه‌نویسان می‌توانند به آسانی با اجراهای ناهمگام کار کنند و کدهایی را بنویسند که به شکلی خوانا و قابل فهم‌تری اجرا می‌شوند. این ویژگی به شکل معمول در کدهایی که با درخواست‌های شبکه، پردازش داده و دیگر عملیات ناهمگام مرتبط هستند، است</p>"
  },
  {
    "title": "13- تفاوت های null و undefined ؟",
    "answer": "<p>Null و Undefined هر دو مقادیر خاص در جاوااسکریپت هستند که به معنای 'تهی' یا 'عدم وجود مقدار' می‌باشند، اما با تفاوت‌های مهمی: <br /> <strong>Undefined </strong> به معنای عدم تعیین یک مقدار است. اگر یک متغیر تعریف شده باشد اما به آن مقداری اختصاص داده نشده باشد، مقدار آن undefined خواهد بود. <br /> وقتی که یک تابع بدون دسترسی به مقداری return شود، مقدار بازگشتی undefined است. <br /> وقتی که یک متغیر به صورت اعلامی تعریف شده اما از قبل مقداردهی نشده است، مقدار آن undefined خواهد بود. <br /> <strong>Null </strong> به معنای عدم وجود یک مقدار است. این به طور خاص برای نشان دادن اینکه یک متغیر یا شیء دارای مقداری نیست استفاده می‌شود. <br /> وقتی می‌خواهیم بیان کنیم که یک متغیر یا یک شیء از نظر مفهومی 'تهی' است ولی تعریف شده است، Null را بکار می‌بریم. <br /> Null اغلب به عنوان مقداری برای تعیین وضعیت‌های خاص مانند 'متغیری تعریف شده است اما مقداری ندارد' یا 'یک شیء وجود دارد اما مقداری ندارد' استفاده می‌شود. <br /> به طور خلاصه، اصلی‌ترین تفاوت بین Null و Undefined این است که Null به معنای عدم وجود مقدار است، در حالی که Undefined به معنای عدم تعیین یک مقدار است.</p>"
  },
  {
    "title": "14- data type های مختلف در جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، داده‌ها می‌توانند به صورت مختلفی تعریف شوند. در زیر، برخی از انواع داده‌ای مهم در جاوااسکریپت را بررسی می‌کنیم: <br /> <small>اعداد (Numbers): </small> اعداد در جاوا اسکریپت به صورت عدد صحیح (integer) یا عدد اعشاری (floating-point) وارد می‌شوند. برای مثال: 5, 3.14. <br /> <small>رشته‌ها (Strings): </small> رشته‌ها برای نمایش متن و مقادیر متنی در جاوا اسکریپت استفاده می‌شوند. رشته‌ها باید با نقل قول تکی یا دوتایی محصور شوند. <br /> <small>بولی (Boolean): </small> بولی یک نوع داده است که تنها دو مقدار ممکن دارد: true یا false. این نوع داده برای نمایش وضعیت منطقی استفاده می‌شود. <br /> <small>آرایه‌ها (Arrays): </small> آرایه‌ها یک مجموعه از مقادیر متفاوت با اندیس‌های عددی مرتبط هستند. برای مثال: [1, 2, 3, 4, 5]. <br /> <small>شیء (Objects): </small> مجموعه‌ای از ویژگی‌ها (properties) که هر کدام دارای یک مقدار و یک کلید (key) است. اشیاء در جاوااسکریپت به صورت {} تعریف می‌شوند و ویژگی‌ها به وسیلهٔ اسامی ویژگی‌ها مشخص می‌شوند. برای مثال: { name: 'John', age: 30 }. <br /> <small>توابع (Functions): </small> توابع نیز یک نوع داده در جاوااسکریپت هستند. آنها می‌توانند به عنوان مقادیر به متغیرها اختصاص داده شوند و به عنوان آرگومان‌ها به توابع دیگر فرستاده شوند. <br /> <small>نوع Null و Undefined: </small> این دو نوع برای نشان دادن عدم وجود مقدار یا متغیری مورد استفاده قرار می‌گیرند. Null به عنوان یک مقدار خاص برای نشان دادن عدم وجود یک مقدار استفاده می‌شود، در حالی که Undefined برای نشان دادن اینکه یک متغیر مقداردهی نشده است، استفاده می‌شود. <br /> <small>نوع Symbol (ES6): </small> یک نوع داده جدید است که با استفاده از آن می‌توانید یک مقدار یکتا ایجاد کنید که قابل مشاهده نیست و قابل تغییر نیز نیست. <br /> این تعدادی از انواع داده‌های مهم در جاوا اسکریپت هستند. همچنین می‌توان از ساختارهای داده‌ای پیشرفته‌تر مانند Map، Set  نیز استفاده کرد که در زبان جاوااسکریپت وجود دارند.</p>"
  },
  {
    "title": "15- تفاوت reference type و primitive type ؟",
    "answer": "<p>تفاوت اصلی بین نوع مرجع (Reference Type) و نوع ابتدایی یا اولیه (Primitive Type) در جاوااسکریپت در روش ذخیره و دسترسی به داده‌هاست. در زیر توضیحات بیشتری درباره هرکدام آورده شده است: <br /> <strong>نوع مرجع (Reference Type): </strong><br /> نوع مرجع به داده‌هایی اشاره دارد که به صورت مستقیم در متغیرها ذخیره نمی‌شوند، بلکه به جای آن یک اشاره به مکان حافظه‌ای که داده واقعی در آن قرار دارد، ذخیره می‌شود. اشیاء (Objects)، آرایه‌ها (Arrays)، توابع (Functions) و سایر داده‌ساختارهای پیچیده مانند Map و Set از نوع مرجع هستند. هنگامی که یک متغیر به یک مقدار مرجعی (مانند یک شیء یا یک آرایه) اختصاص می‌یابد، در واقع یک ارجاع به مکان حافظه ایجاد می‌شود و تغییراتی که در مقدار اصلی اعمال می‌شود، در تمام متغیرهایی که به آن ارجاع دارند، قابل مشاهده هستند. <br /> <strong>نوع ابتدایی یا اولیه (Primitive Type):</strong><br /> نوع ابتدایی یا اولیه به داده‌هایی اشاره دارد که به صورت مستقیم در متغیرها ذخیره می‌شوند و به مکان حافظه‌ای دیگری اشاره نمی‌کنند. اعداد (Numbers)، رشته‌ها (Strings)، بولی‌ها (Booleans)، NaN، Null و Undefined از نوع ابتدایی هستند. <br> به طور کلی، تفاوت اصلی بین Primitive Type و Reference Type در جاوا اسکریپت این است که اعضای مرجعی قابل تغییر هستند و تغییرات در یک متغیر مرجعی تأثیر مستقیم بر دیگر متغیرهایی که به همان مقدار اشاره می‌کنند، دارد. اما در Primitive Type، تغییرات فقط بر روی متغیر اصلی تأثیرگذار است و سایر متغیرها هیچ تغییری نخواهند کرد.</p>"
  },
  {
    "title": "16- تفاوت heap memory و stack memory ؟",
    "answer": "<p>در زبان‌های برنامه‌نویسی مانند جاوا اسکریپت، حافظه به دو قسمت اصلی تقسیم می‌شود: حافظه‌ی متناهی (Stack Memory) و حافظه‌ی پویا (Heap Memory). این دو حافظه به منظور ذخیره‌سازی داده‌ها و اجرای برنامه استفاده می‌شوند، اما تفاوت‌های مهمی دارند: <br /> <strong>Stack Memory (حافظه پشته): </strong><br /> Stack Memory یک حافظه‌ی کوچک است که برای ذخیره‌سازی متغیرها، متغیرهای محلی توابع، آدرس بازگشت و سایر اطلاعات مورد نیاز برای اجرای فرآیندها استفاده می‌شود. داده‌هایی که در Stack Memory ذخیره می‌شوند، به صورت پشته‌ای (LIFO) مدیریت می‌شوند؛ به این معنا که آخرین داده‌ای که به آن اضافه می‌شود، اولین داده‌ای است که از پشته حذف می‌شود. <br /> Stack Memory به طور معمول به صورت خودکار مدیریت می‌شود و هنگامی که یک تابع فراخوانی می‌شود، یک فریم جدید برای آن تابع در پشته ایجاد می‌شود و هنگامی که تابع اجرای خود را تمام می‌کند، فریم مربوطه از پشته حذف می‌شود. <br /> <strong>Heap Memory (حافظه‌ی پویا): </strong><br /> حافظه Heap برای ذخیره داده‌هایی استفاده می‌شود که نیاز به ذخیرهای پویا و زمان زیادی برای ماندگاری دارند، مانند شیء‌ها و آرایه‌ها. <br /> داده‌هایی که در حافظه Heap ذخیره می‌شوند، به صورت دستی مدیریت می‌شوند و باید به صورت صریح توسط برنامه‌نویس آزادسازی شوند. <br /> حافظه Heap معمولاً بزرگتر و پرتراکمتر از حافظه Stack است و برای داده‌هایی که نیاز به زمان طولانی‌تری برای ذخیره‌سازی دارند، مورد استفاده قرار می‌گیرد. <br /> به طور خلاصه، تفاوت اصلی بین Heap Memory و Stack Memory در جاوا اسکریپت این است که Stack Memory برای ذخیره‌سازی متغیرهای محلی و اجرای فرآیندها استفاده می‌شود و به صورت خودکار مدیریت می‌شود، در حالی که Heap Memory برای ذخیره‌سازی داده‌هایی با زندگی زمانی غیرقابل پیش‌بینی استفاده می‌شود و نیاز به مدیریت دستی دارد.</p>"
  },
  {
    "title": "17- مفهوم single thread در جاوااسکریپت ؟",
    "answer": "<p>در جاوا اسکریپت، مفهوم single thread به معنای اجرای کدها و انجام عملیات‌ها در یک نخ (thread) اجرایی است. به عبارت دیگر، در محیط اجرایی جاوا اسکریپت، فقط یک نخ اصلی برای اجرای کدها وجود دارد. <br /> ویژگی single thread در جاوا اسکریپت به معنای این است که در یک زمان مشخص، تنها یک عملیات می‌تواند اجرا شود و برنامه‌نویس باید از مکانیزم‌های ناهمگام مانند Callbacks، Promises و Async/Await استفاده کند تا اجرای عملیات‌های زمان‌بر و مانع از بلاکه شدن (blocking) نخ اصلی باشد. <br /> وقتی که یک برنامه جاوا اسکریپت اجرا می‌شود، کدها به صورت خطی از بالا به پایین اجرا می‌شوند، بدون همزمانی یا تقسیم اجرا به چندین نخ. این به این معنی است که هر دستور به ترتیب اجرا می‌شود و برنامه از یک نخ اصلی برای انجام تمامی عملیات استفاده می‌کند. <br /> این ویژگی از جاوا اسکریپت به دلیل محیط اجرایی اصلی آن، یعنی مرورگر و محیط Node.js، است. این محیط‌ها اجازه اجرای کد در یک نخ را می‌دهند، که این اجراها به صورت ترتیبی و همروند انجام می‌شوند. این ویژگی ممکن است محدودیت‌هایی را در مواردی که نیاز به انجام عملیات‌های همزمان دارید، ایجاد کند، اما از طرف دیگر، سادگی و قابلیت پیاده‌سازی بیشتری دارد.</p>"
  },
  {
    "title": "18- تفاوت setTimeout و setInterval ؟",
    "answer": "<p>در جاوا اسکریپت، setTimeout و setInterval دو تابع مهم برای اجرای کدها به صورت (Asynchronous) هستند. این دو تابع به شما اجازه می‌دهند تا کدهای خود را پس از مدت زمان مشخصی اجرا کنید. اما تفاوت اصلی بین این دو تابع به شرح زیر است: <br /> <span>setTimeout </span> به شما اجازه می‌دهد تا یک تابع یا یک قطعه کد را پس از یک مدت زمان معین اجرا کنید. سینتکس setTimeout به شکل زیر است: <code> setTimeout(callback, delay); </code> <small>callback: </small> یک تابع یا قطعه کد که باید پس از انقضای زمان مشخص اجرا شود. <br /> <small>delay: </small> مدت زمان (به میلی‌ثانیه) که باید صبر کنید تا تابع اجرا شود. <br /> setTimeout تنها یکبار تابع را اجرا می‌کند. <br /><br /> <span>setInterval </span> نیز به شما اجازه می‌دهد تا یک تابع یا یک قطعه کد را به صورت مکرر و با فاصله‌ی زمانی ثابت اجرا کنید. سینتکس setInterval به شکل زیر است: <code> setInterval(callback, interval); </code> <small>callback: </small> یک تابع یا قطعه کد که باید به صورت مکرر اجرا شود. <br /> <small>interval: </small> فاصله‌ی زمانی (به میلی‌ثانیه) بین هر بار اجرای تابع. <br /> setInterval تا زمانی که برنامه اجرا می‌شود، تابع را به صورت مکرر اجرا می‌کند. <br /> مورد استفاده اصلی setTimeout و setInterval در جاوا اسکریپت، ایجاد انیمیشن‌ها، به روزرسانی داده‌ها در زمان مشخص و اجرای کدها در بازه‌های زمانی معین می‌باشد. اما باید به دقت از آنها استفاده کرد تا از مشکلاتی مانند ایجاد حلقه‌های بی‌نهایت (Infinity Loops) یا افزایش بی‌نهایت بار CPU پرهیز شود.</p>"
  },
  {
    "title": "19- json چیست ؟",
    "answer": "<p><strong>JSON</strong> مخفف عبارت 'JavaScript Object Notation' است و یک فرمت متنی است که برای تبادل داده‌ها استفاده می‌شود. JSON از یک ساختار داده‌ای ساده و قابل خواندن برای انسان استفاده می‌کند و می‌تواند داده‌ها را به صورت متنی در قالب اشیاء (Objects) و آرایه‌ها (Arrays) نمایش دهد. <br /> <span>ویژگی‌های کلیدی JSON عبارتند از: </span> <br /> <small>خوانایی بالا: </small>JSON به صورت متنی است و برای انسان‌ها بسیار خوانا است. این فرمت برای نمایش داده‌ها در قالب ساختارهای ساده مانند آرایه‌ها و شیء‌ها (اشیاء) طراحی شده است. <br /> <small> سازگاری با زبان‌های مختلف: </small> JSON به عنوان یک فرمت مستقل از زبان استفاده می‌شود و به راحتی با زبان‌های برنامه‌نویسی مختلفی مانند جاوااسکریپت، پایتون، جاوا، C++ و غیره سازگار است. <br /> <small>سادگی استفاده: </small> JSON برای تعریف ساختار داده‌ها از اشیاء (objects)، آرایه‌ها، رشته‌ها، اعداد و مقادیر بولی استفاده می‌کند. این ساختارها به راحتی قابل فهم و استفاده هستند. <br /> <small>حجم کم و سرعت بالا: </small> به دلیل سادگی و خوانایی بالای JSON، حجم داده‌ها به صورت متنی کمتر است و برای انتقال اطلاعات با سرعت بالا مناسب است. <br /> JSON معمولاً برای انتقال داده‌های میان برنامه‌های وب (بین مرورگر و سرور)، ذخیره و بازیابی تنظیمات و پیکربندی‌ها، و تبادل داده‌ها بین سیستم‌های مختلف استفاده می‌شود. به عنوان مثال، وقتی که شما یک درخواست AJAX از مرورگر خود به سرور ارسال می‌کنید، اطلاعات معمولاً به صورت JSON به سرور ارسال و پس از پردازش به مرورگر برگردانده می‌شوند.<p>"
  },
  {
    "title": "20- regular-expression چیست ؟",
    "answer": "<p>Regular Expression یا همان عبارت منظم، الگوهای متنوعی است که برای جستجو، تطابق و جایگزینی متن در رشته‌های متنوع استفاده می‌شود. این الگوها از یک سری کاراکترها و متاکاراکترها (کاراکترهای ویژه) تشکیل شده‌اند که الگوی مورد نظر را تعیین می‌کنند. <br /> با استفاده از Regular Expression می‌توانید الگوهایی را تعریف کنید که با یک یا چند کاراکتر مشخص متن تطابق داشته باشند. برای مثال، می‌توانید الگویی بسازید که با یک عدد صحیح، یک رشته حروفی یا حتی یک آدرس ایمیل تطابق داشته باشد. <br /> متاکاراکترها از علامتهایی مانند ^ (شروع رشته)، $ (پایان رشته)، /d (یک رقم)، /w (یک حرف، یک عدد یا یک خط تیره) و ... تشکیل شده‌اند. این متاکاراکترها به شما امکان می‌دهند الگوهای پیچیده‌تری را تعریف کنید. <br /> استفاده از Regular Expression در برنامه‌نویسی بسیار مفید است، زیرا این امکان را به برنامه‌نویس می‌دهد که به راحتی الگوهای مشخصی را جستجو و تغییر دهد. از جمله کاربردهای معمول Regular Expression می‌توان به جستجوی الگویی در متن، جایگزینی متن، اعتبارسنجی ورودی‌ها، تجزیه و تحلیل داده‌ها و ... اشاره کرد. <br /> برای مثال، اگر بخواهیم یک الگوی Regex برای جستجوی تمام آدرس‌های ایمیل در یک متن ایجاد کنیم، می‌توانیم از الگوی زیر استفاده کنیم: <code> /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+/.[a-zA-Z]{2,}/ </code> همچنین، اگر بخواهیم تاریخ‌ها را از یک متن استخراج کنیم، می‌توانیم از یک الگوی Regex مانند زیر استفاده کنیم: <code> //d{4}-/d{2}-/d{2}/ </code> با استفاده از Regular Expression‌ها، می‌توانید الگوهای پیچیده‌تری را جستجو کنید، رشته‌ها را تغییر دهید و یا اطلاعات مورد نظر را از رشته‌ها استخراج کنید. این یک ابزار قدرتمند برای کار با متون است و در بسیاری از وظایف پردازش متنی بسیار مفید است.</p>"
  },
  {
    "title": "21- تفاوت break و continue ؟",
    "answer": "<p>در زبان‌های برنامه‌نویسی مانند جاوا اسکریپت، Break و Continue دو دستور کنترل جریان (Flow Control) هستند که استفاده آن‌ها می‌تواند در حل مسائل و پردازش داده‌ها مفید باشد. این دو دستور تفاوت‌ها و کاربردهای متفاوتی دارند: <br /> <strong>Break: </strong> دستور Break معمولاً در داخل یک حلقه (مثل حلقه for یا while) استفاده می‌شود. <br /> وقتی که دستور Break اجرا می‌شود، اجرای حلقه فوراً متوقف می‌شود و کنترل به خارج از حلقه منتقل می‌شود. <br /> Break معمولاً برای خروج از حلقه به طور ناگهانی بر اساس یک شرط خاص استفاده می‌شود. بعد از اجرای دستور Break، هیچ بار دیگری از حلقه اجرا نمی‌شود و اجرای برنامه به دستوری که بلافاصله بعد از حلقه قرار دارد ادامه می‌یابد.<br> <strong>Continue: </strong> دستور Continue نیز در داخل حلقه استفاده می‌شود. <br /> وقتی که دستور Continue اجرا می‌شود، اجرای حلقه به طور ناگهانی به ابتدای حلقه باز می‌گردد و باقی عبارات داخل حلقه نادیده گرفته می‌شوند. <br /> Continue معمولاً برای پرش به مرحله‌ی بعدی حلقه (بدون اجرای کدهای دیگر داخل حلقه) استفاده می‌شود. بعد از اجرای دستور Continue، بار دیگری از حلقه اجرا می‌شود و اجرای برنامه به ابتدای حلقه بازمی‌گردد. <br /> به طور خلاصه، Break برای خروج ناگهانی از حلقه‌ها و Continue برای انجام یک پرش به مرحله بعدی در حلقه استفاده می‌شود. این دو دستور به برنامه‌نویس امکان می‌دهند که جریان اجرای برنامه را به دقت کنترل کند و با شرایط خاصی که ممکن است پیش بیاید، برخوردهای مناسب را داشته باشد.</p>"
  },
  {
    "title": "22- عملگر unary چیست ؟",
    "answer": "<p>عملگر Unary یک نوع عملگر در برنامه‌نویسی است که بر روی یک عمله یا عملگر اعمال می‌شود و فقط یک عمله یا عملگر را در نظر می‌گیرد. به عبارت دیگر، Unary به تنهایی بر روی یک متغیر یا مقدار عملیات انجام می‌دهد. <br /> در جاوا اسکریپت و بسیاری از زبان‌های برنامه‌نویسی دیگر، Unary Operator‌ها به صورت پیشوندی یا پسوندی می‌توانند باشند. به طور کلی، عملگر Unary می‌تواند بر روی متغیر‌ها، عبارات، یا مقادیر عملیات انجام دهد. <br /> برخی از Unary Operator‌های رایج در جاوا اسکریپت عبارتند از: <br /> <small>Increment (++) و Decrement (--): </small> برای افزایش یا کاهش مقدار یک متغیر. <br /> <small>Unary Plus (+) و Unary Minus (-): </small> برای تبدیل یک عبارت به عدد مثبت یا منفی. <br /> <small>Logical Negation (!): </small> برای انجام عملگر منطقی نقیض (not) بر روی یک مقدار بولی. <br /> <small>TypeOf: </small> برای بازگرداندن نوع داده‌ای یک متغیر. <br /> <small>Delete: </small> برای حذف یک ویژگی یا یک عنصر از یک شیء. <br /> <small>Void: </small>برای تعیین مقدار undefined به یک عبارت. <br /> و غیره. <br /> مثال‌ها: <code> let x = 10;<br /> let y = -x; // Unary Minus <br /> let z = ++x; // Increment (prefix) <br /> let a = !true; // Logical Negation <br /> let b = typeof x; // TypeOf <br /> </code> در هر یک از مثال‌ها، Unary Operator بر روی یک متغیر یا مقدار اعمال شده است و تنها یک عمله یا مقدار را در نظر گرفته است. <br /> به طور کلی، عملگر Unary معمولاً برای انجام عملیات ساده و سریع بر روی مقادیر یا متغیرها استفاده می‌شود</p>"
  },
  {
    "title": "23- spread operator چیست ؟",
    "answer": "<p>عملگر گسترش یا Spread Operator در جاوااسکریپت یک عملگر است که به شما امکان می‌دهد داده‌ها را از یک مکان به مکان دیگر گسترش دهید یا انتقال دهید. این عملگر اغلب برای انتقال عناصر آرایه‌ها، اشیاء (Objects) یا مقادیر متغیرها به عنوان آرگومان‌های یک تابع یا برای ایجاد آرایه‌های جدید با ادغام عناصر آرایه‌های موجود استفاده می‌شود. <br /> در جاوااسکریپت، عملگر گسترش با سه نقطه (...) نمایش داده می‌شود. به طور کلی، این عملگر به شما امکان می‌دهد داده‌ها را به عنوان آرگومان‌ها به توابع منتقل کنید یا داده‌های یک آرایه را به صورت جداگانه در یک آرایه جدید اضافه کنید. <br /> برای مثال، در تعریف تابعی که چندین آرگومان متغیر را می‌پذیرد، می‌توانید از عملگر گسترش برای انتقال آرایه یا آبجکت‌های دیگر به عنوان آرگومان‌ها استفاده کنید. همچنین، می‌توانید از این عملگر برای ایجاد یک آرایه جدید با ادغام عناصر آرایه‌های مختلف استفاده کنید. <br> <strong>مهمترین کاربردهای Spread Operator عبارتند از: </strong><br /> <small>گسترش آرایه‌ها (Array Spreading): </small> <br /> می‌توانید از Spread Operator برای ترکیب یک آرایه با آرایه‌های دیگر یا اضافه کردن یک مقدار جدید به آرایه استفاده کنید. به عنوان مثال: <code> const array1 = [1, 2, 3]; <br /> const array2 = [4, 5, 6]; <br /> const combinedArray = [...array1, ...array2]; // [1, 2, 3, 4, 5, 6] <br /> </code> <small>انتقال آرگومان‌ها (Argument Spreading): </small> <br /> می‌توانید Spread Operator را برای انتقال آرگومان‌ها به یک تابع استفاده کنید. به عنوان مثال: <code> function myFunction(x, y, z) { <br /> console.log(x, y, z); <br /> } <br /> const args = [0, 1, 2];<br /> myFunction(...args); // 0 1 2 </code> <small>کپی کردن آبجکت‌ها (Object Copying): </small><br /> می‌توانید از Spread Operator برای کپی کردن یک آبجکت به صورت کامل یا اضافه کردن خصوصیت‌های جدید به آبجکت استفاده کنید. به عنوان مثال: <code> const obj1 = { name: 'John', age: 30 }; <br /> const obj2 = { ...obj1, city: 'New York' };<br /> console.log(obj2); // { name: 'John', age: 30, city: 'New York' } </code> Spread Operator یک ویژگی قدرتمند است که کد را خوانا تر و کارآمدتر می‌کند و به برنامه‌نویسان این امکان را می‌دهد تا با کار کردن با داده‌ها به صورت سریعتر و منطقی‌تر، کد های کوتاهتر و خواناتری بنویسند.</p>"
  },
  {
    "title": "24- map و set ؟",
    "answer": "<p>Map و Set دو ساختار داده مهم در جاوااسکریپت هستند که به شما امکان می‌دهند تا داده‌های خود را در یک مجموعه مرتب (Map) یا بدون تکرار (Set) ذخیره کنید و به آن‌ها دسترسی داشته باشید. این دو ساختار داده دارای ویژگی‌ها و کاربردهای متفاوتی هستند: <br /> <span>Map</span> یک مجموعه داده است که از جفت‌های 'کلید-مقدار' تشکیل شده است. به عبارت دیگر، هر عنصر در Map شامل یک کلید و مقدار متناظر است. <br /> کلیدها در یک Map می‌توانند هر نوع داده‌ای (شامل رشته، عدد، شیء و غیره) باشند. <br /> Map تضمین می‌کند که عناصر در آن به ترتیب اضافه شده‌اند و قابلیت حذف، به روزرسانی و جستجو بر اساس کلید را فراهم می‌کند. <br /> برخی از متد‌های مهم Map عبارتند از: set()، get()، has()، delete()، clear()، keys()، values() و entries(). <code> const myMap = new Map(); <br /> myMap.set('key1', 'value1');<br /> myMap.set('key2', 'value2');<br /> console.log(myMap.get('key1')); // 'value1'<br /> console.log(myMap.has('key2')); // true<br /> </code> <span>Set</span> یک مجموعه داده بدون تکرار است که تنها مقادیر منحصر به فرد را در خود ذخیره می‌کند. عناصر در یک Set بدون ترتیب خاصی ذخیره می‌شوند، به عبارت دیگر، ترتیب اضافه شدن آنها مهم نیست. <br /> Set قابلیت اضافه کردن عناصر جدید، حذف عناصر موجود و بررسی وجود عناصر را فراهم می‌کند. <br /> برخی از متد‌های مهم Set عبارتند از: add()، delete()، has() و clear(). <code> const mySet = new Set();<br /> mySet.add('apple');<br /> mySet.add('banana');<br /> mySet.add('apple'); // تکراری، اضافه نمی‌شود<br /> console.log(mySet.has('banana')); // true<br /> console.log(mySet.size); // 2<br /> </code> با استفاده از Map و Set، می‌توانید به راحتی با داده‌های خود کار کنید و عملیات‌های مختلفی از جمله اضافه کردن، حذف، بررسی و دسترسی به داده‌ها را انجام دهید. انتخاب بین استفاده از Map و Set بستگی به نوع داده‌هایی دارد که برنامه شما نیاز دارد و آیا شما نیاز به داشتن کلید-مقدار (Map) دارید یا خیر (Set).</p>"
  },
  {
    "title": "25- مفهوم prototype ؟",
    "answer": "<p>در جاوااسکریپت، هر شیء از یک Prototype (نمونه‌ی اصلی) به عنوان الگویی برای ارث‌بری مشتق می‌کند. Prototype یک شیء دیگر است که دارای ویژگی‌ها و رفتارهایی است که به شیء اصلی ارجاع دارد. به این ترتیب، شیء اصلی (که همچنین به عنوان یک instance نیز شناخته می‌شود) از ویژگی‌ها و رفتارهای موجود در Prototype خود بهره می‌برد. <br /> به طور معمول، اشیاء در جاوااسکریپت از Prototype خود به عنوان الگو استفاده می‌کنند تا ویژگی‌ها و رفتارهای مشترک را به اشتراک بگذارند. این به معنای آن است که اگر یک ویژگی یا متدی در Prototype تغییر کند، تمام اشیاء مشتق شده از آن Prototype نیز به طور خودکار این تغییرات را ارث می‌برند. <br /> برای تعریف یک Prototype، می‌توانید از تابع سازنده‌ی یک شیء یا به صورت مستقیم از ویژگی prototype که در هر تابع در جاوااسکریپت وجود دارد، استفاده کنید. از طریق Prototype، می‌توانید ویژگی‌ها و متدهای مشترک را بین اشیاء به اشتراک بگذارید. <br /> به عنوان مثال: <code> // تعریف یک تابع سازنده به نام Person<br /> function Person(name, age) {<br /> this.name = name;<br /> this.age = age;<br /> }<br /> // اضافه کردن یک متد به Prototype تابع Person<br /> Person.prototype.sayHello = function() {<br /> console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);<br /> }<br /> // ساخت یک شیء از نوع Person<br /> const person1 = new Person('Alice', 30);<br /> const person2 = new Person('Bob', 25);<br /> // فراخوانی متد sayHello بر روی شیء person1<br /> person1.sayHello(); // Hello, my name is Alice and I am 30 years old.<br /> </code> در این مثال، Person.prototype به عنوان Prototype برای شیء‌های ایجاد شده از تابع سازنده‌ی Person استفاده می‌شود. وقتی که متد sayHello به Prototype اضافه می‌شود، تمام اشیاء مشتق شده از تابع Person این متد را به ارث می‌برند و می‌توانند از آن استفاده کنند.</p>"
  }
]
