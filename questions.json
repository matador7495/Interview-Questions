[
  {
    "title": "1- تفاوت عملگرهای == و === ؟",
    "answer": "<p>عملگرهای == و === در جاوااسکریپت برای مقایسه مقادیر استفاده می‌شوند، اما تفاوت اصلی بین آنها در نحوه انجام مقایسه و نوع داده‌هایی که توانایی مقایسه آنها را دارند است <br /> <strong> == :</strong> این عملگر برای مقایسه مقادیر استفاده می‌شود. زمانی که از این عملگر استفاده می‌کنید، داده‌ها را با توجه به مقدار آنها مقایسه می‌کند. اگر مقادیر دو متغیر یکسان باشند، مقایسه موفق خواهد بود. <br /> <strong> === :</strong> این عملگر نیز برای مقایسه مقادیر استفاده می‌شود، اما با این تفاوت که علاوه بر مقایسه مقادیر، نوع داده‌ها نیز بررسی می‌شود. اگر دو مقدار نه تنها مساوی باشند بلکه همچنین نوع داده‌های آنها نیز یکسان باشد، مقایسه با === موفق خواهد بود. این عملگر به عنوان 'مقایسه دقیق' شناخته می‌شود. <br /> به عنوان مثال: <code> console.log(5 == '5'); // true <br /> console.log(5 === '5'); // false </code> در مثال بالا، در مقایسه اول (==)، مقدار‌های دو متغیر برابر هستند، بنابراین مقایسه موفق خواهد بود. اما در مقایسه دوم (===)، علاوه بر بررسی مقدار، نوع داده‌ها نیز بررسی می‌شود، بنابراین مقایسه ناموفق خواهد بود زیرا مقدار 5 (عدد) با '5' (رشته) هم‌مساوی نیست.</p>"
  },
  {
    "title": "2- تفاوت متدهای slice و splice ؟",
    "answer": "<p>متدهای slice و splice هر دو در جاوا اسکریپت برای کار با آرایه‌ها استفاده می‌شوند، اما کاربردها و عملکردهای آنها متفاوت است: <br /> <strong>slice(): </strong> برای ایجاد یک کپی از بخشی از آرایه استفاده می‌شود، بدون تغییر در آرایه اصلی. این متد دو پارامتر می‌پذیرد، شروع و پایان بخش مورد نظر برای کپی. این متد یک زیرآرایه از آرایه مبدا را برمی‌گرداند بدون تغییر در آرایه اصلی. نحوه استفاده: array.slice(start, end) <br /> <strong>splice(): </strong> برای تغییر محتوای یک آرایه استفاده می‌شود، از جمله حذف و یا اضافه کردن عناصر. این متد سه پارامتر می‌پذیرد، شروع، تعداد عناصری که می‌خواهید حذف کنید و هر عنصری که می‌خواهید به آرایه اضافه کنید. این متد عناصر حذف شده را برمی‌گرداند و آرایه اصلی را نیز تغییر می‌دهد.<br> نحوه استفاده: array.splice(start, deleteCount, item1, item2, ...) به عنوان مثال: <code> let array = [1, 2, 3, 4, 5]; <br /> // استفاده از slice <br /> let slicedArray = array.slice(1, 3); // [2, 3] <br /> console.log(array); // [1, 2, 3, 4, 5] (آرایه اصلی تغییر نمی‌کند) <br /> // استفاده از splice <br /> let splicedArray = array.splice(1, 2); // حذف [2, 3] <br /> console.log(array); // [1, 4, 5] (آرایه اصلی تغییر می‌کند) <br /> console.log(splicedArray); // [2, 3] (آرایه حذف شده) <br /> </code> بنابراین، تفاوت اصلی بین slice() و splice() این است که slice() یک زیرآرایه از آرایه اصلی را بدون تغییر آن برمی‌گرداند، در حالی که splice() عناصری را از آرایه اصلی حذف یا به آن اضافه می‌کند و آرایه اصلی را تغییر می‌دهد.</p>"
  },
  {
    "title": "3- تابع higher-order چیست ؟",
    "answer": "<p> تابع <strong>higher-order</strong> یک مفهوم مهم در برنامه‌نویسی است که به توابعی اشاره دارد که یا به عنوان آرگومان به یک تابع دیگر پاس داده می‌شوند یا از طریق بازگرداندن یک تابع به عنوان خروجی به عنوان نتیجه، تعامل بالاتری با توابع دیگر ایجاد می‌کنند. <br> به طور خاص، اگر یک تابع، یک تابع دیگر را به عنوان ورودی دریافت کند یا یک تابع را به عنوان خروجی برگرداند، به عنوان یک تابع Higher-Order شناخته می‌شود. این تابع‌ها به عنوان توابع اولیه (First-Class Functions) شناخته می‌شوند. <br> با استفاده از توابع Higher-Order، می‌توانید از انعطاف بیشتری در برنامه‌نویسی خود برخوردار شوید. این امکان را به شما می‌دهد که توابع را به عنوان داده‌هایی قابل انتقال مورد استفاده قرار دهید و از آنها برای ایجاد توابع پویا و چندمنظوره استفاده کنید. <br> <span>مثال‌هایی از توابع Higher-Order عبارتند از:</span> <br> <small> (Callback Functions):</small> ارسال تابع به عنوان یک پارامتر به یک تابع دیگر و استفاده از آن در زمانی که شرایط خاصی برآورده شود، مانند رویدادها در محیط وب. <br> <small> (Higher-Order Functions):</small> تابعی که یک تابع دیگر را به عنوان ورودی دریافت می‌کند و یک تابع جدید را به عنوان خروجی برمی‌گرداند، مانند map، filter و reduce در جاوااسکریپت. <br> <small> (Closure Functions):</small> توابعی که یک تابع را به عنوان ورودی دریافت می‌کنند و متغیرهای محلی خود را در یک محیط بسته (closure) ذخیره می‌کنند. <br> استفاده از توابع Higher-Order می‌تواند کد را خواناتر، ساده‌تر و قابل تعمیرتر کند و اجازه می‌دهد که برنامه‌ها به صورت مؤثر و قابل اطمینان اجرا شوند. <br> تابعی که یک تابع را به عنوان ورودی می‌پذیرد: <code> function operate(func, x, y) { return func(x, y); } <br> function add(a, b) { return a + b; } <br> function multiply(a, b) { return a * b; } <br> console.log(operate(add, 2, 3)); // 5 <br> console.log(operate(multiply, 2, 3)); // 6 </code> تابعی که یک تابع را به عنوان خروجی برمی‌گرداند: <br><code> function multiplier(factor) { return function(x) { return x * factor; }; } <br> let double = multiplier(2); <br> console.log(double(5)); // 10 <br> let triple = multiplier(3); <br> console.log(triple(5)); // 15 </code> Callback functions (توابع بازخوانی): <br><code> function processArray(arr, callback) { let result = []; for (let item of arr) { result.push(callback(item)); } return result; } <br> let numbers = [1, 2, 3, 4, 5]; <br> function square(x) { return x * x; } <br> let squaredNumbers = processArray(numbers, square); br console.log(squaredNumbers); // [1, 4, 9, 16, 25] </code></p>"
  },
  {
    "title": "4- تفاوت let و const و var ؟",
    "answer": "<p> تفاوت بین let، const و var در جاوا اسکریپت به روش تعریف و محدودیت تغییرپذیری متغیرها مربوط می‌شود. در اینجا تفاوت‌های اصلی آنها را بررسی می‌کنیم: <br /><strong>var :</strong> در ES5 معرفی شده است و قبل از اینکه let و const معرفی شوند، برای تعریف متغیرها استفاده می‌شد. متغیرهای تعریف شده با var دارای scope بلوکی نیستند، به عبارت دیگر، در محدوده‌ی بلاک‌ها، تابع‌ها و حتی برخی موارد دیگر مانند حلقه‌های for، تغییر پذیرند. <br /> متغیرهای تعریف شده با var قابلیت hoisting دارند، به این معنی که متغیرها قبل از اینکه تعریف شوند، به بالای محدوده قابل دسترسی می‌شوند. متغیرهایی که با var تعریف می‌شوند، قابلیت تغییر مقدار را دارند. می‌توان یک متغیر با var را دوباره تعریف کرد بدون دریافت خطا (redeclaration). <br /><strong>let :</strong> در ES6 (یا ECMAScript 2015) معرفی شده است و از آن به عنوان جایگزین بهتر برای var استفاده می‌شود. متغیرهای تعریف شده با let دارای scope بلوکی هستند، به عبارت دیگر، محدوده دقیق‌تری دارند و معمولاً بهترین روش برای تعریف متغیرها است. <br /> متغیرهای تعریف شده با let قابلیت hoisting را ندارند، به این معنی که قبل از تعریف، به بالای محدوده قابل دسترسی نیستند. می‌توان مقدار متغیرهای let را تغییر داد، یعنی این متغیرها می‌توانند reassigned شوند. امکان تعریف مجدد یک متغیر با let وجود ندارد، اگر دوباره تعریف شود، خطا ایجاد می‌شود. <br /><strong>const :</strong> نیز در ES6 معرفی شده است و برای تعریف ثابت‌ها (متغیرهایی که مقدار آنها بعد از تعریف تغییر نمی‌کند) استفاده می‌شود. متغیرهای تعریف شده با const نیاز به مقدار اولیه دارند و مقدار آنها نمی‌تواند پس از تعریف تغییر کند. مانند let، متغیرهای تعریف شده با const دارای scope بلوکی هستند. <br /> متغیرهای تعریف شده با const قابلیت hoisting را ندارند. اگر متغیری با const یک شیء یا یک آرایه را مشخص کند، می‌توان ویژگی‌های شیء یا مقادیر آرایه را تغییر داد، اما نمی‌توان متغیر خود را reassigned کرد. <code> var x = 10;<br> let y = 20;<br> const z = 30;<br> x = 15; // متغیر x را می‌توان تغییر داد<br> y = 25; // متغیر y را می‌توان تغییر داد<br> // z = 35; // خطا! مقدار متغیر const نمی‌تواند تغییر کند<br> var x = 5; // دوباره تعریف متغیر x با var ممکن است<br> // let y = 10; // خطا! تعریف مجدد متغیر با let ممکن نیست<br> // const z = 15; // خطا! تعریف مجدد متغیر const ممکن نیست<br> </code> بنابراین، استفاده از let و const به عنوان جایگزینی برای var توصیه می‌شود، زیرا آنها دارای scope بلوکی هستند و امکاناتی را برای ایجاد کد بهتر و امن‌تر فراهم می‌کنند. </p>"
  },
  {
    "title": "5- hoisting در جاوااسکریپت ؟",
    "answer": "<p><strong>Hoisting</strong> به این معنی است که در جاوااسکریپت، تعریف متغیرها و توابع به صورت خودکار به بالای محدوده ای که در آن قرار دارند (یا به بالای کد محلی یا به بالای کد یک تابع) منتقل می‌شوند، به عبارت دیگر، متغیرها و توابعی که با استفاده از var تعریف می‌شوند، قبل از اجرای کد به بالای اسکوپ مربوطه منتقل می‌شوند. به طور دقیق‌تر، هنگامی که یک متغیر یا تابع با var تعریف می‌شود، جاوا اسکریپت در فاز کامپایل کد (قبل از اجرای آن) این تعاریف را به بالای اسکوپ مربوطه منتقل می‌کند. اما مقادیر این متغیرها در همان مکانی که از آنها استفاده می‌شود، نیستند؛ بلکه مقدار اولیه آنها در زمان اجرای کد تخصیص داده می‌شود. <br /> برای مثال: <code> console.log(x); // undefined <br> var x = 10;<br> console.log(x); // 10 <br> console.log(y()); // 'Hello, World!' <br> function y() { return 'Hello, World!'; } </code> در این مثال، اگرچه تعریف متغیر x پس از استفاده از آن (در خط اول) است، اما به دلیل hoisting، متغیر x به بالای اسکوپ منتقل شده و console.log(x) بدون خطا اجرا می‌شود. اما در زمان اجرا، مقدار x هنوز تعیین نشده است و به همین دلیل undefined چاپ می‌شود. سپس مقدار 10 به x تخصیص داده می‌شود و در خط سوم، console.log(x) مقدار 10 را چاپ می‌کند و همچنین تابع y به‌ صورت صحیح اجرا می شود. <br> به عنوان یک نکته، hoisting فقط برای تعریف‌هایی که با var صورت می‌گیرد اعمال می‌شود و برای تعریف‌هایی که با let یا const انجام می‌شود، این رفتار صورت نمی‌گیرد. این تفاوت مهمی است که بهبودی در ایمنی و قابلیت خوانایی کد ایجاد می‌کند.</p>"
  },
  {
    "title": "6- تفاوت cookie و local-storage و session-storage ؟",
    "answer": "<p>تمام این سه روش ذخیره‌سازی اطلاعات در مرورگرهای وب مورد استفاده قرار می‌گیرند، اما تفاوت‌های مهمی در عملکرد و کاربردهای آنها وجود دارد: <br /> <strong>Cookie :</strong><br /> یک روش ذخیره‌سازی اطلاعات در مرورگر است که بین سرور و مرورگر به صورت رشته‌های کوچک ارسال می‌شود. <br /> حداکثر حجم ذخیره‌سازی آن محدود به ۴KB است.<br /> همراه با هر درخواست به سرور ارسال می‌شود، این موجب می‌شود که مقدار زیادی از ترافیک شبکه اضافی به وجود آید.<br /> اطلاعات می‌تواند تا زمان انقضای مشخص شده باقی بماند یا تا زمانی که کاربر آن را پاک کند.<br /> <strong>localStorage :</strong><br /> یک فضای ذخیره‌سازی پایدار در مرورگر است که اطلاعات در آن به صورت کلید/مقدار (key/value) ذخیره می‌شوند. <br /> معمولاً حداکثر ۵MB حجم ذخیره‌سازی را دارا می‌باشد.<br /> اطلاعات موجود در localStorage تا زمانی که کاربر آن را پاک نکند، ثابت باقی می‌ماند.<br /> اطلاعات در localStorage از طریق JavaScript قابل دسترسی و تغییر هستند.<br /> اطلاعات در Local Storage توسط وب سایت‌های دیگر دیده نمی‌شوند و تنها توسط وب سایتی که آنها را ذخیره کرده است قابل دسترسی هستند.<br /> برای ذخیره اطلاعاتی که برای محلی بودن داده‌ها نیاز است و به سرور ارسال نمی‌شوند مفید است، مانند تنظیمات کاربر و داده‌های سمت کلاینت.<br /> <strong>sessionStorage :</strong><br>  مشابه localStorage عمل می‌کند، اما اطلاعات ذخیره شده در آن تنها برای جلسه فعلی مرورگر (یا تب) معتبر است و پس از بسته شدن تب، اطلاعات حذف می‌شوند. <br> همچنین معمولاً حداکثر ۵MB حجم ذخیره‌سازی را دارا می‌باشد.<br> برای اطلاعات موقتی که نیاز به حذف شدن پس از پایان یک نشست دارند مناسب است، مانند اطلاعات فرم موقت یا موقعیت کاربر در یک نشست.<br> اگر نیاز به ذخیره داده‌ها بین جلسات مرورگر داشته باشید و این داده‌ها باید با هر درخواست به سرور ارسال شوند، از cookie استفاده کنید. اگر نیاز به ذخیره داده‌ها برای مدت زمان بیشتری باشد و می‌خواهید اطلاعات پس از بسته شدن تب فعلی مرورگر نیز باقی بمانند، از localStorage استفاده کنید. اگر نیاز به ذخیره داده‌ها تنها برای جلسه فعلی مرورگر باشد، از sessionStorage استفاده کنید.<br> به طور خلاصه، کوکی‌ها برای اطلاعات کوچک و مرتبط با کاربر، Local Storage برای داده‌های بزرگتر و دائمی و Session Storage برای داده‌های موقت و مرتبط با جلسه استفاده می‌شوند.</p>"
  },
  {
    "title": "7- closure چیست ؟",
    "answer": "<p><strong>Closure :</strong> یکی از مفاهیم مهم در جاوااسکریپت است که در برنامه‌نویسی مدرن بسیار استفاده می‌شود. به طور کلی، Closure به معنای این است که یک تابع داخلی (inner function) به داده‌ها و متغیرهای محیط خارجی خود دسترسی دارد، حتی بعد از اینکه تابع خارجی (outer function) اجرا شده باشد و اجرای آن به پایان رسیده باشد. <br /> به عبارت دیگر، یک Closure شامل یک تابع داخلی است که به متغیرها و پارامترهای تابع خارجی خود دسترسی دارد. این تابع داخلی می‌تواند این متغیرها را برای محاسبه یا انجام عملیات دیگر استفاده کند و حتی پس از اتمام اجرای تابع خارجی، دسترسی به این متغیرها را داشته باشد. <br /> استفاده از Closure به ما امکان می‌دهد تا محیط محلی تابع را حفظ کرده و از متغیرها و اطلاعات موجود در آنها برای استفاده در توابع داخلی بهره ببریم، بدون اینکه نگرانی داشته باشیم که این اطلاعات با اتمام اجرای تابع خارجی از بین برود. <br /> یک مثال ساده از Closure در جاوااسکریپت: <br /><code> function outerFunction() {<br> let outerVariable = 'I am outer!';<br> function innerFunction() {<br> console.log(outerVariable); // دسترسی به متغیر بیرونی<br> } <br> return innerFunction;<br> } <br> let closure = outerFunction();<br> closure(); // اجرای تابع داخلی با استفاده از کلوژر </code> در این مثال، تابع innerFunction دارای دسترسی به متغیر outerVariable از تابع outerFunction است، حتی پس از اینکه outerFunction به پایان رسیده است. این امر به وجود کلوژر برمی‌گردد که innerFunction توانایی دسترسی به متغیرها و پارامترهای outerFunction را فراهم می‌کند، از جمله پس از اجرای outerFunction. <br> مزیت اصلی کلوژر در این است که توانایی ایجاد محیط‌های داده از قبل معین شده و انتقال متغیرها و اطلاعات بین توابع را فراهم می‌کند، بدون اینکه این اطلاعات به صورت عمومی در دسترس دیگر بخش‌های برنامه باشند. این امر امکان ایجاد کدی بسیار منظمتر و قابل تعمیم را فراهم می‌کند.</p>"
  },
  {
    "title": "8- module چیست ؟",
    "answer": "<p><strong>ماژول‌ها (Modules) :</strong>در جاوا اسکریپت به شیوه‌ای برای تقسیم برنامه به بخش‌های کوچک‌تر و مدیریت کد بهتر کمک می‌کنند. مفهوم ماژول در جاوا اسکریپت به صورت رسمی در استاندارد ECMAScript 2015 (معروف به ES6) معرفی شد و ابزارهای مختلفی برای استفاده از ماژول‌ها در جاوا اسکریپت وجود دارد، از جمله وارد کردن و صادر کردن ماژول‌ها با استفاده از import و export. <br /> <span>مزایای استفاده از ماژول‌ها عبارتند از: </span><br /> <small>سازماندهی بهتر کد:</small> ماژول‌ها به تقسیم بندی کد به بخش‌های کوچکتر کمک می‌کنند که به راحتی قابل مدیریت و توسعه هستند. <br /> <small>رفع تداخل نام:</small> ماژول‌ها به صورت مستقل از یکدیگر عمل می‌کنند، بنابراین از تداخل نام‌ها در متغیرها و توابع در سطح سراسری برنامه جلوگیری می‌کنند. <br /> <small>قابلیت استفاده مجدد (Reusability):</small> با استفاده از ماژول‌ها، می‌توانید کد را به شکل مستقلی ایجاد کنید که بعداً در پروژه‌های دیگر قابل استفاده باشد. <br /> ماژول‌ها می‌توانند توابع، کلاس‌ها، متغیرها و سایر اجزای کد را شامل شوند و معمولاً یک فایل جداگانه برای هر ماژول ایجاد می‌شود. سپس ماژول‌ها را می‌توان با استفاده از import و export در دیگر فایل‌ها به کار برد. این کار امکان ایجاد برنامه‌های بزرگتر و پیچیده‌تر را با کدی که بهبود یافته و بهتر سازماندهی شده است، فراهم می‌کند.</p>"
  },
  {
    "title": "9- مفهوم asynchronous جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، اجرای کد به صورت همزمان (Synchronous) و غیرهمزمان (Asynchronous) اتفاق می‌افتد. <br> در جاوا اسکریپت، مفهوم Asynchronous به استفاده از کدهایی اشاره دارد که اجرای آنها به صورت همزمان با سایر عملیات‌ها انجام می‌شود، بدون اینکه انتظار برای اتمام آن عملیات‌ها وجود داشته باشد. به عبارت دیگر، اجرای کدها به صورت غیرهمزمان انجام می‌شود. <br> استفاده از کدهای غیرهمزمان مفید است زمانی که برنامه نیاز به انجام عملیات‌هایی دارد که ممکن است زمان زیادی طول بکشد، مانند خواندن اطلاعات از پایگاه داده، درخواست اطلاعات از سرور، یا اجرای عملیات‌های پرهزینه محاسباتی. در این صورت، به جای انتظار برای اتمام این عملیات‌ها، برنامه می‌تواند به سایر کدهای خود ادامه دهد و بعداً به نتیجه این عملیات‌ها بازگردد. <br> برای ایجاد عملیات غیرهمزمان در جاوا اسکریپت، از مکانیزم‌هایی مانند Callbacks، Promises، و Async/Await استفاده می‌شود. این مکانیزم‌ها به برنامه امکان اجرای عملیات‌های غیرهمزمان و مدیریت بهتر جریان کد را می‌دهند، این مکانیسم‌ها به برنامه‌نویس اجازه می‌دهند که به صورت راحت‌تر با اجراهای Asynchronous کار کنند و کد را به شکلی خوانا و قابل نگهداری تر بنویسند.</p>"
  },
  {
    "title": "10- promise چیست و چرا به آن نیاز داریم ؟",
    "answer": "<p><strong>Promise :</strong> در جاوااسکریپت یک الگوی برنامه‌نویسی است که برای مدیریت عملیات‌های ناهمگام (Asynchronous) استفاده می‌شود. یک Promise یک شیء قابل انتظار است که نتیجه یک عملیات ناهمگام را نشان می‌دهد، می‌تواند مقدار یا خطا باشد. Promise به برنامه‌نویس اجازه می‌دهد که با عملیاتی که طول می‌کشد به صورت بهتر و قابل پیش‌بینی‌تر برخورد کند. <br /> <span>مزایای استفاده از Promise عبارتند از:</span> <br /> <small>مدیریت اجراهای ناهمگام:</small> با استفاده از Promise، می‌توانیم به راحتی با اجراهای ناهمگام کار کنیم، مانند درخواست‌های شبکه، خواندن و نوشتن فایل‌ها، و دسترسی به پایگاه داده. <br /> <small>کد خوانا:</small> Promise اجازه می‌دهد که کد نوشته شده برای اجراهای ناهمگام قابل خواندن‌تر و قابل نگهداری‌تر باشد. با استفاده از زنجیره‌ای از then و catch، می‌توان کد را به صورت ساختار یافته‌تری نوشت و اشکالات راحت‌تر پیدا کرد. <br /> <small>مدیریت خطا:</small> Promise امکان مدیریت خطاها را فراهم می‌کند. با استفاده از catch، می‌توانیم خطاهایی که در طول اجرای Promise رخ می‌دهند را به صورت مرتب و منظم مدیریت کنیم. <br /> <span>یک Promise می‌تواند در یکی از سه حالت از نظر وضعیت باشد:</span> <br /> <small>Pending:</small> وضعیت اولیه که هنگامی که Promise ایجاد شده است، از این حالت شروع می‌شود.<br /> <small>Fulfilled (Resolved):</small> وضعیتی که Promise با موفقیت اجرا شده و مقدار خروجی مورد انتظار تولید شده است.<br /> <small>Rejected:</small> وضعیتی که Promise به دلیل خطا یا شرایط نامطلوب دیگر نتوانست مقدار مورد انتظار را تولید کند.<br /> به طور کلی، Promise به برنامه‌نویس اجازه می‌دهد تا با راحتی و انعطاف بیشتری عملیات‌های ناهمگام را مدیریت کند و به کدی تمیزتر و خواناتر دست پیدا کند. این بهبود در ساختار و قابلیت‌های برنامه‌نویسی به معنایی بهتر و کارایی بیشتر برنامه می‌باشد.</p>"
  },
  {
    "title": "11- توابع callback - مزایا و معایب آن ؟",
    "answer": "<p><strong>توابع callback </strong> یک الگوی برنامه‌نویسی در جاوااسکریپت هستند که در اجراهای ناهمگام و همچنین در مواقعی که نیاز به اجرای کدی بعد از اتمام یک عملیات خاص داریم، استفاده می‌شوند. این توابع به عنوان پارامتر به توابع دیگر ارسال شده و بعد از اتمام عملیات مورد نظر، فراخوانی می‌شوند. در زیر مزایا و معایب استفاده از توابع callback آورده شده است.<br /> <span>مزایا :</span><br /> <small> مدیریت بهتر اجراهای ناهمگام :</small> Callback Functions اجازه می‌دهند تا کدهایی که باید بعد از اتمام یک عملیات ناهمگام اجرا شوند، به آسانی تعریف و مدیریت شوند. <br /> <small>کد قابل باز استفاده :</small>استفاده از توابع callback امکان استفاده مجدد از کدها را فراهم می‌کند، زیرا می‌توان یک تابع callback را به یک تابع دیگر ارسال کرد و همچنین توابع callback قابل استفاده مجدد هستند. <br /> <small>انعطاف‌پذیری بالا :</small> از آنجایی که توابع بازخوانی به عنوان پارامتر به توابع دیگر ارسال می‌شوند، این الگو انعطاف‌پذیری بالایی در استفاده از کدها را فراهم می‌کند و امکان تعویض عملکرد توابع را فراهم می‌کند. <br /> <span>معایب :</span><br /> <small>کد ناخوانا و پیچیده :</small>استفاده از توابع callback ممکن است منجر به کدی شود که دشوار قابل فهم و پیچیده باشد، به ویژه زمانی که بیش از یک تابع callback مورد استفاده قرار بگیرد و یا وابستگی‌های پیچیده‌ای ایجاد شود. <br /> <small>Callback Hell :</small>زمانی که توابع بازخوانی به صورت متوالی تو در تو قرار می‌گیرند، ممکن است در موقعیتی به نام 'Callback Hell' یا 'Pyramid of Doom' بیافتید که کد بسیار پیچیده و دشوار به خواندن و نگهداری است. <br /> <small>مدیریت خطا :</small>مدیریت خطا در توابع بازخوانی ممکن است دشوار باشد، زیرا خطاها ممکن است در توابع بازخوانی مختلف و به صورت غیر همزمان رخ دهند و باید با دقت مدیریت شوند. <br /> به طور کلی، توابع بازخوانی می‌توانند به عنوان یک الگوی برنامه‌نویسی کارا و مؤثر برای مدیریت اجراهای ناهمگام مورد استفاده قرار بگیرند، اما باید با معایب و محدودیت‌های آن آشنا باشید و از روش‌های بهتری مانند Promise یا Async/Await نیز استفاده کنید.</p>"
  },
  {
    "title": "12- کاربرد async/await ؟",
    "answer": "<p><strong>Async/Await</strong> یک ویژگی جدید در جاوااسکریپت است که با انتشار استاندارد ES2017 (یا ES8) معرفی شد. این ویژگی به برنامه‌نویسان اجازه می‌دهد تا به آسانی با اجراهای ناهمگام (Asynchronous) کار کنند و کدهایی را که به صورت متوالی اجرا می‌شوند به شکلی مانند کدهای همزمان نوشته شوند. <br /> <span>کاربردهای Async/Await عبارتند از :</span><br /> <small>سادگی خواندن کد: </small>Async/Await امکان نوشتن کدی را فراهم می‌کند که به صورت همزمان و مرتبط به نظر می‌رسد، بدون نیاز به توابع بازخوانی (Callback Functions) یا توابع Promise.then(). <br /> <small>مدیریت و پیگیری خطاها: </small>از آنجایی که Async/Await در واقع یک نوع شکل‌دهی به توابع Promise است، امکان مدیریت خطاها با استفاده از try/catch فراهم می‌شود، که کار با خطاها را آسان‌تر و خواناتر می‌کند. <br /> <small>پیگیری و استفاده از مقادیر بازگشتی: </small>از آنجایی که Async/Await به صورت مستقیم مقدار بازگشتی تابع Promise را به شکل همزمان فراهم می‌کند، این امکان فراهم می‌شود که مقادیر بازگشتی را بدون نیاز به زنجیره‌سازی توابع then() دستکاری و استفاده کنید. <br /> <small>کارایی و قابلیت انتقال: </small>Async/Await به برنامه‌نویس امکان می‌دهد که به سادگی بین توابع همگام و ناهمگام تغییر کند، بدون اینکه بخش‌های زیادی از کد را عوض کند. <br /> با استفاده از Async/Await، برنامه‌نویسان می‌توانند به آسانی با اجراهای ناهمگام کار کنند و کدهایی را بنویسند که به شکلی خوانا و قابل فهم‌تری اجرا می‌شوند. این ویژگی به شکل معمول در کدهایی که با درخواست‌های شبکه، پردازش داده و دیگر عملیات ناهمگام مرتبط هستند، است</p>"
  },
  {
    "title": "13- تفاوت های null و undefined ؟",
    "answer": "<p>Null و Undefined هر دو مقادیر خاص در جاوااسکریپت هستند که به معنای 'تهی' یا 'عدم وجود مقدار' می‌باشند، اما با تفاوت‌های مهمی: <br /> <strong>Undefined </strong> به معنای عدم تعیین یک مقدار است. اگر یک متغیر تعریف شده باشد اما به آن مقداری اختصاص داده نشده باشد، مقدار آن undefined خواهد بود. <br /> وقتی که یک تابع بدون دسترسی به مقداری return شود، مقدار بازگشتی undefined است. <br /> وقتی که یک متغیر به صورت اعلامی تعریف شده اما از قبل مقداردهی نشده است، مقدار آن undefined خواهد بود. <br /> <strong>Null </strong> به معنای عدم وجود یک مقدار است. این به طور خاص برای نشان دادن اینکه یک متغیر یا شیء دارای مقداری نیست استفاده می‌شود. <br /> وقتی می‌خواهیم بیان کنیم که یک متغیر یا یک شیء از نظر مفهومی 'تهی' است ولی تعریف شده است، Null را بکار می‌بریم. <br /> Null اغلب به عنوان مقداری برای تعیین وضعیت‌های خاص مانند 'متغیری تعریف شده است اما مقداری ندارد' یا 'یک شیء وجود دارد اما مقداری ندارد' استفاده می‌شود. <br /> به طور خلاصه، اصلی‌ترین تفاوت بین Null و Undefined این است که Null به معنای عدم وجود مقدار است، در حالی که Undefined به معنای عدم تعیین یک مقدار است.</p>"
  },
  {
    "title": "14- data type های مختلف در جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، داده‌ها می‌توانند به صورت مختلفی تعریف شوند. در زیر، برخی از انواع داده‌ای مهم در جاوااسکریپت را بررسی می‌کنیم: <br /> <small>اعداد (Numbers): </small> اعداد در جاوا اسکریپت به صورت عدد صحیح (integer) یا عدد اعشاری (floating-point) وارد می‌شوند. برای مثال: 5, 3.14. <br /> <small>رشته‌ها (Strings): </small> رشته‌ها برای نمایش متن و مقادیر متنی در جاوا اسکریپت استفاده می‌شوند. رشته‌ها باید با نقل قول تکی یا دوتایی محصور شوند. <br /> <small>بولی (Boolean): </small> بولی یک نوع داده است که تنها دو مقدار ممکن دارد: true یا false. این نوع داده برای نمایش وضعیت منطقی استفاده می‌شود. <br /> <small>آرایه‌ها (Arrays): </small> آرایه‌ها یک مجموعه از مقادیر متفاوت با اندیس‌های عددی مرتبط هستند. برای مثال: [1, 2, 3, 4, 5]. <br /> <small>شیء (Objects): </small> مجموعه‌ای از ویژگی‌ها (properties) که هر کدام دارای یک مقدار و یک کلید (key) است. اشیاء در جاوااسکریپت به صورت {} تعریف می‌شوند و ویژگی‌ها به وسیلهٔ اسامی ویژگی‌ها مشخص می‌شوند. برای مثال: { name: 'John', age: 30 }. <br /> <small>توابع (Functions): </small> توابع نیز یک نوع داده در جاوااسکریپت هستند. آنها می‌توانند به عنوان مقادیر به متغیرها اختصاص داده شوند و به عنوان آرگومان‌ها به توابع دیگر فرستاده شوند. <br /> <small>نوع Null و Undefined: </small> این دو نوع برای نشان دادن عدم وجود مقدار یا متغیری مورد استفاده قرار می‌گیرند. Null به عنوان یک مقدار خاص برای نشان دادن عدم وجود یک مقدار استفاده می‌شود، در حالی که Undefined برای نشان دادن اینکه یک متغیر مقداردهی نشده است، استفاده می‌شود. <br /> <small>نوع Symbol (ES6): </small> یک نوع داده جدید است که با استفاده از آن می‌توانید یک مقدار یکتا ایجاد کنید که قابل مشاهده نیست و قابل تغییر نیز نیست. <br /> این تعدادی از انواع داده‌های مهم در جاوا اسکریپت هستند. همچنین می‌توان از ساختارهای داده‌ای پیشرفته‌تر مانند Map، Set  نیز استفاده کرد که در زبان جاوااسکریپت وجود دارند.</p>"
  },
  {
    "title": "15- تفاوت reference type و primitive type ؟",
    "answer": "<p>تفاوت اصلی بین نوع مرجع (Reference Type) و نوع ابتدایی یا اولیه (Primitive Type) در جاوااسکریپت در روش ذخیره و دسترسی به داده‌هاست. در زیر توضیحات بیشتری درباره هرکدام آورده شده است: <br /> <strong>نوع مرجع (Reference Type): </strong><br /> نوع مرجع به داده‌هایی اشاره دارد که به صورت مستقیم در متغیرها ذخیره نمی‌شوند، بلکه به جای آن یک اشاره به مکان حافظه‌ای که داده واقعی در آن قرار دارد، ذخیره می‌شود. اشیاء (Objects)، آرایه‌ها (Arrays)، توابع (Functions) و سایر داده‌ساختارهای پیچیده مانند Map و Set از نوع مرجع هستند. هنگامی که یک متغیر به یک مقدار مرجعی (مانند یک شیء یا یک آرایه) اختصاص می‌یابد، در واقع یک ارجاع به مکان حافظه ایجاد می‌شود و تغییراتی که در مقدار اصلی اعمال می‌شود، در تمام متغیرهایی که به آن ارجاع دارند، قابل مشاهده هستند. <br /> <strong>نوع ابتدایی یا اولیه (Primitive Type):</strong><br /> نوع ابتدایی یا اولیه به داده‌هایی اشاره دارد که به صورت مستقیم در متغیرها ذخیره می‌شوند و به مکان حافظه‌ای دیگری اشاره نمی‌کنند. اعداد (Numbers)، رشته‌ها (Strings)، بولی‌ها (Booleans)، NaN، Null و Undefined از نوع ابتدایی هستند. <br> به طور کلی، تفاوت اصلی بین Primitive Type و Reference Type در جاوا اسکریپت این است که اعضای مرجعی قابل تغییر هستند و تغییرات در یک متغیر مرجعی تأثیر مستقیم بر دیگر متغیرهایی که به همان مقدار اشاره می‌کنند، دارد. اما در Primitive Type، تغییرات فقط بر روی متغیر اصلی تأثیرگذار است و سایر متغیرها هیچ تغییری نخواهند کرد.</p>"
  },
  {
    "title": "16- تفاوت heap memory و stack memory ؟",
    "answer": "<p>در زبان‌های برنامه‌نویسی مانند جاوا اسکریپت، حافظه به دو قسمت اصلی تقسیم می‌شود: حافظه‌ی متناهی (Stack Memory) و حافظه‌ی پویا (Heap Memory). این دو حافظه به منظور ذخیره‌سازی داده‌ها و اجرای برنامه استفاده می‌شوند، اما تفاوت‌های مهمی دارند: <br /> <strong>Stack Memory (حافظه پشته): </strong><br /> Stack Memory یک حافظه‌ی کوچک است که برای ذخیره‌سازی متغیرها، متغیرهای محلی توابع، آدرس بازگشت و سایر اطلاعات مورد نیاز برای اجرای فرآیندها استفاده می‌شود. داده‌هایی که در Stack Memory ذخیره می‌شوند، به صورت پشته‌ای (LIFO) مدیریت می‌شوند؛ به این معنا که آخرین داده‌ای که به آن اضافه می‌شود، اولین داده‌ای است که از پشته حذف می‌شود. <br /> Stack Memory به طور معمول به صورت خودکار مدیریت می‌شود و هنگامی که یک تابع فراخوانی می‌شود، یک فریم جدید برای آن تابع در پشته ایجاد می‌شود و هنگامی که تابع اجرای خود را تمام می‌کند، فریم مربوطه از پشته حذف می‌شود. <br /> <strong>Heap Memory (حافظه‌ی پویا): </strong><br /> حافظه Heap برای ذخیره داده‌هایی استفاده می‌شود که نیاز به ذخیرهای پویا و زمان زیادی برای ماندگاری دارند، مانند شیء‌ها و آرایه‌ها. <br /> داده‌هایی که در حافظه Heap ذخیره می‌شوند، به صورت دستی مدیریت می‌شوند و باید به صورت صریح توسط برنامه‌نویس آزادسازی شوند. <br /> حافظه Heap معمولاً بزرگتر و پرتراکمتر از حافظه Stack است و برای داده‌هایی که نیاز به زمان طولانی‌تری برای ذخیره‌سازی دارند، مورد استفاده قرار می‌گیرد. <br /> به طور خلاصه، تفاوت اصلی بین Heap Memory و Stack Memory در جاوا اسکریپت این است که Stack Memory برای ذخیره‌سازی متغیرهای محلی و اجرای فرآیندها استفاده می‌شود و به صورت خودکار مدیریت می‌شود، در حالی که Heap Memory برای ذخیره‌سازی داده‌هایی با زندگی زمانی غیرقابل پیش‌بینی استفاده می‌شود و نیاز به مدیریت دستی دارد.</p>"
  },
  {
    "title": "17- مفهوم single thread در جاوااسکریپت ؟",
    "answer": "<p>در جاوا اسکریپت، مفهوم single thread به معنای اجرای کدها و انجام عملیات‌ها در یک نخ (thread) اجرایی است. به عبارت دیگر، در محیط اجرایی جاوا اسکریپت، فقط یک نخ اصلی برای اجرای کدها وجود دارد. <br /> ویژگی single thread در جاوا اسکریپت به معنای این است که در یک زمان مشخص، تنها یک عملیات می‌تواند اجرا شود و برنامه‌نویس باید از مکانیزم‌های ناهمگام مانند Callbacks، Promises و Async/Await استفاده کند تا اجرای عملیات‌های زمان‌بر و مانع از بلاکه شدن (blocking) نخ اصلی باشد. <br /> وقتی که یک برنامه جاوا اسکریپت اجرا می‌شود، کدها به صورت خطی از بالا به پایین اجرا می‌شوند، بدون همزمانی یا تقسیم اجرا به چندین نخ. این به این معنی است که هر دستور به ترتیب اجرا می‌شود و برنامه از یک نخ اصلی برای انجام تمامی عملیات استفاده می‌کند. <br /> این ویژگی از جاوا اسکریپت به دلیل محیط اجرایی اصلی آن، یعنی مرورگر و محیط Node.js، است. این محیط‌ها اجازه اجرای کد در یک نخ را می‌دهند، که این اجراها به صورت ترتیبی و همروند انجام می‌شوند. این ویژگی ممکن است محدودیت‌هایی را در مواردی که نیاز به انجام عملیات‌های همزمان دارید، ایجاد کند، اما از طرف دیگر، سادگی و قابلیت پیاده‌سازی بیشتری دارد.</p>"
  },
  {
    "title": "18- تفاوت setTimeout و setInterval ؟",
    "answer": "<p>در جاوا اسکریپت، setTimeout و setInterval دو تابع مهم برای اجرای کدها به صورت (Asynchronous) هستند. این دو تابع به شما اجازه می‌دهند تا کدهای خود را پس از مدت زمان مشخصی اجرا کنید. اما تفاوت اصلی بین این دو تابع به شرح زیر است: <br /> <span>setTimeout </span> به شما اجازه می‌دهد تا یک تابع یا یک قطعه کد را پس از یک مدت زمان معین اجرا کنید. سینتکس setTimeout به شکل زیر است: <code> setTimeout(callback, delay); </code> <small>callback: </small> یک تابع یا قطعه کد که باید پس از انقضای زمان مشخص اجرا شود. <br /> <small>delay: </small> مدت زمان (به میلی‌ثانیه) که باید صبر کنید تا تابع اجرا شود. <br /> setTimeout تنها یکبار تابع را اجرا می‌کند. <br /><br /> <span>setInterval </span> نیز به شما اجازه می‌دهد تا یک تابع یا یک قطعه کد را به صورت مکرر و با فاصله‌ی زمانی ثابت اجرا کنید. سینتکس setInterval به شکل زیر است: <code> setInterval(callback, interval); </code> <small>callback: </small> یک تابع یا قطعه کد که باید به صورت مکرر اجرا شود. <br /> <small>interval: </small> فاصله‌ی زمانی (به میلی‌ثانیه) بین هر بار اجرای تابع. <br /> setInterval تا زمانی که برنامه اجرا می‌شود، تابع را به صورت مکرر اجرا می‌کند. <br /> مورد استفاده اصلی setTimeout و setInterval در جاوا اسکریپت، ایجاد انیمیشن‌ها، به روزرسانی داده‌ها در زمان مشخص و اجرای کدها در بازه‌های زمانی معین می‌باشد. اما باید به دقت از آنها استفاده کرد تا از مشکلاتی مانند ایجاد حلقه‌های بی‌نهایت (Infinity Loops) یا افزایش بی‌نهایت بار CPU پرهیز شود.</p>"
  },
  {
    "title": "19- json چیست ؟",
    "answer": "<p><strong>JSON</strong> مخفف عبارت 'JavaScript Object Notation' است و یک فرمت متنی است که برای تبادل داده‌ها استفاده می‌شود. JSON از یک ساختار داده‌ای ساده و قابل خواندن برای انسان استفاده می‌کند و می‌تواند داده‌ها را به صورت متنی در قالب اشیاء (Objects) و آرایه‌ها (Arrays) نمایش دهد. <br /> <span>ویژگی‌های کلیدی JSON عبارتند از: </span> <br /> <small>خوانایی بالا: </small>JSON به صورت متنی است و برای انسان‌ها بسیار خوانا است. این فرمت برای نمایش داده‌ها در قالب ساختارهای ساده مانند آرایه‌ها و شیء‌ها (اشیاء) طراحی شده است. <br /> <small> سازگاری با زبان‌های مختلف: </small> JSON به عنوان یک فرمت مستقل از زبان استفاده می‌شود و به راحتی با زبان‌های برنامه‌نویسی مختلفی مانند جاوااسکریپت، پایتون، جاوا، C++ و غیره سازگار است. <br /> <small>سادگی استفاده: </small> JSON برای تعریف ساختار داده‌ها از اشیاء (objects)، آرایه‌ها، رشته‌ها، اعداد و مقادیر بولی استفاده می‌کند. این ساختارها به راحتی قابل فهم و استفاده هستند. <br /> <small>حجم کم و سرعت بالا: </small> به دلیل سادگی و خوانایی بالای JSON، حجم داده‌ها به صورت متنی کمتر است و برای انتقال اطلاعات با سرعت بالا مناسب است. <br /> JSON معمولاً برای انتقال داده‌های میان برنامه‌های وب (بین مرورگر و سرور)، ذخیره و بازیابی تنظیمات و پیکربندی‌ها، و تبادل داده‌ها بین سیستم‌های مختلف استفاده می‌شود. به عنوان مثال، وقتی که شما یک درخواست AJAX از مرورگر خود به سرور ارسال می‌کنید، اطلاعات معمولاً به صورت JSON به سرور ارسال و پس از پردازش به مرورگر برگردانده می‌شوند.<p>"
  },
  {
    "title": "20- regular-expression چیست ؟",
    "answer": "<p>Regular Expression یا همان عبارت منظم، الگوهای متنوعی است که برای جستجو، تطابق و جایگزینی متن در رشته‌های متنوع استفاده می‌شود. این الگوها از یک سری کاراکترها و متاکاراکترها (کاراکترهای ویژه) تشکیل شده‌اند که الگوی مورد نظر را تعیین می‌کنند. <br /> با استفاده از Regular Expression می‌توانید الگوهایی را تعریف کنید که با یک یا چند کاراکتر مشخص متن تطابق داشته باشند. برای مثال، می‌توانید الگویی بسازید که با یک عدد صحیح، یک رشته حروفی یا حتی یک آدرس ایمیل تطابق داشته باشد. <br /> متاکاراکترها از علامتهایی مانند ^ (شروع رشته)، $ (پایان رشته)، /d (یک رقم)، /w (یک حرف، یک عدد یا یک خط تیره) و ... تشکیل شده‌اند. این متاکاراکترها به شما امکان می‌دهند الگوهای پیچیده‌تری را تعریف کنید. <br /> استفاده از Regular Expression در برنامه‌نویسی بسیار مفید است، زیرا این امکان را به برنامه‌نویس می‌دهد که به راحتی الگوهای مشخصی را جستجو و تغییر دهد. از جمله کاربردهای معمول Regular Expression می‌توان به جستجوی الگویی در متن، جایگزینی متن، اعتبارسنجی ورودی‌ها، تجزیه و تحلیل داده‌ها و ... اشاره کرد. <br /> برای مثال، اگر بخواهیم یک الگوی Regex برای جستجوی تمام آدرس‌های ایمیل در یک متن ایجاد کنیم، می‌توانیم از الگوی زیر استفاده کنیم: <code> /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+/.[a-zA-Z]{2,}/ </code> همچنین، اگر بخواهیم تاریخ‌ها را از یک متن استخراج کنیم، می‌توانیم از یک الگوی Regex مانند زیر استفاده کنیم: <code> //d{4}-/d{2}-/d{2}/ </code> با استفاده از Regular Expression‌ها، می‌توانید الگوهای پیچیده‌تری را جستجو کنید، رشته‌ها را تغییر دهید و یا اطلاعات مورد نظر را از رشته‌ها استخراج کنید. این یک ابزار قدرتمند برای کار با متون است و در بسیاری از وظایف پردازش متنی بسیار مفید است.</p>"
  },
  {
    "title": "21- تفاوت break و continue ؟",
    "answer": "<p>در زبان‌های برنامه‌نویسی مانند جاوا اسکریپت، Break و Continue دو دستور کنترل جریان (Flow Control) هستند که استفاده آن‌ها می‌تواند در حل مسائل و پردازش داده‌ها مفید باشد. این دو دستور تفاوت‌ها و کاربردهای متفاوتی دارند: <br /> <strong>Break: </strong> دستور Break معمولاً در داخل یک حلقه (مثل حلقه for یا while) استفاده می‌شود. <br /> وقتی که دستور Break اجرا می‌شود، اجرای حلقه فوراً متوقف می‌شود و کنترل به خارج از حلقه منتقل می‌شود. <br /> Break معمولاً برای خروج از حلقه به طور ناگهانی بر اساس یک شرط خاص استفاده می‌شود. بعد از اجرای دستور Break، هیچ بار دیگری از حلقه اجرا نمی‌شود و اجرای برنامه به دستوری که بلافاصله بعد از حلقه قرار دارد ادامه می‌یابد.<br> <strong>Continue: </strong> دستور Continue نیز در داخل حلقه استفاده می‌شود. <br /> وقتی که دستور Continue اجرا می‌شود، اجرای حلقه به طور ناگهانی به ابتدای حلقه باز می‌گردد و باقی عبارات داخل حلقه نادیده گرفته می‌شوند. <br /> Continue معمولاً برای پرش به مرحله‌ی بعدی حلقه (بدون اجرای کدهای دیگر داخل حلقه) استفاده می‌شود. بعد از اجرای دستور Continue، بار دیگری از حلقه اجرا می‌شود و اجرای برنامه به ابتدای حلقه بازمی‌گردد. <br /> به طور خلاصه، Break برای خروج ناگهانی از حلقه‌ها و Continue برای انجام یک پرش به مرحله بعدی در حلقه استفاده می‌شود. این دو دستور به برنامه‌نویس امکان می‌دهند که جریان اجرای برنامه را به دقت کنترل کند و با شرایط خاصی که ممکن است پیش بیاید، برخوردهای مناسب را داشته باشد.</p>"
  },
  {
    "title": "22- عملگر unary چیست ؟",
    "answer": "<p>عملگر Unary یک نوع عملگر در برنامه‌نویسی است که بر روی یک عمله یا عملگر اعمال می‌شود و فقط یک عمله یا عملگر را در نظر می‌گیرد. به عبارت دیگر، Unary به تنهایی بر روی یک متغیر یا مقدار عملیات انجام می‌دهد. <br /> در جاوا اسکریپت و بسیاری از زبان‌های برنامه‌نویسی دیگر، Unary Operator‌ها به صورت پیشوندی یا پسوندی می‌توانند باشند. به طور کلی، عملگر Unary می‌تواند بر روی متغیر‌ها، عبارات، یا مقادیر عملیات انجام دهد. <br /> برخی از Unary Operator‌های رایج در جاوا اسکریپت عبارتند از: <br /> <small>Increment (++) و Decrement (--): </small> برای افزایش یا کاهش مقدار یک متغیر. <br /> <small>Unary Plus (+) و Unary Minus (-): </small> برای تبدیل یک عبارت به عدد مثبت یا منفی. <br /> <small>Logical Negation (!): </small> برای انجام عملگر منطقی نقیض (not) بر روی یک مقدار بولی. <br /> <small>TypeOf: </small> برای بازگرداندن نوع داده‌ای یک متغیر. <br /> <small>Delete: </small> برای حذف یک ویژگی یا یک عنصر از یک شیء. <br /> <small>Void: </small>برای تعیین مقدار undefined به یک عبارت. <br /> و غیره. <br /> مثال‌ها: <code> let x = 10;<br /> let y = -x; // Unary Minus <br /> let z = ++x; // Increment (prefix) <br /> let a = !true; // Logical Negation <br /> let b = typeof x; // TypeOf <br /> </code> در هر یک از مثال‌ها، Unary Operator بر روی یک متغیر یا مقدار اعمال شده است و تنها یک عمله یا مقدار را در نظر گرفته است. <br /> به طور کلی، عملگر Unary معمولاً برای انجام عملیات ساده و سریع بر روی مقادیر یا متغیرها استفاده می‌شود</p>"
  },
  {
    "title": "23- spread operator چیست ؟",
    "answer": "<p>عملگر گسترش یا Spread Operator در جاوااسکریپت یک عملگر است که به شما امکان می‌دهد داده‌ها را از یک مکان به مکان دیگر گسترش دهید یا انتقال دهید. این عملگر اغلب برای انتقال عناصر آرایه‌ها، اشیاء (Objects) یا مقادیر متغیرها به عنوان آرگومان‌های یک تابع یا برای ایجاد آرایه‌های جدید با ادغام عناصر آرایه‌های موجود استفاده می‌شود. <br /> در جاوااسکریپت، عملگر گسترش با سه نقطه (...) نمایش داده می‌شود. به طور کلی، این عملگر به شما امکان می‌دهد داده‌ها را به عنوان آرگومان‌ها به توابع منتقل کنید یا داده‌های یک آرایه را به صورت جداگانه در یک آرایه جدید اضافه کنید. <br /> برای مثال، در تعریف تابعی که چندین آرگومان متغیر را می‌پذیرد، می‌توانید از عملگر گسترش برای انتقال آرایه یا آبجکت‌های دیگر به عنوان آرگومان‌ها استفاده کنید. همچنین، می‌توانید از این عملگر برای ایجاد یک آرایه جدید با ادغام عناصر آرایه‌های مختلف استفاده کنید. <br> <strong>مهمترین کاربردهای Spread Operator عبارتند از: </strong><br /> <small>گسترش آرایه‌ها (Array Spreading): </small> <br /> می‌توانید از Spread Operator برای ترکیب یک آرایه با آرایه‌های دیگر یا اضافه کردن یک مقدار جدید به آرایه استفاده کنید. به عنوان مثال: <code> const array1 = [1, 2, 3]; <br /> const array2 = [4, 5, 6]; <br /> const combinedArray = [...array1, ...array2]; // [1, 2, 3, 4, 5, 6] <br /> </code> <small>انتقال آرگومان‌ها (Argument Spreading): </small> <br /> می‌توانید Spread Operator را برای انتقال آرگومان‌ها به یک تابع استفاده کنید. به عنوان مثال: <code> function myFunction(x, y, z) { <br /> console.log(x, y, z); <br /> } <br /> const args = [0, 1, 2];<br /> myFunction(...args); // 0 1 2 </code> <small>کپی کردن آبجکت‌ها (Object Copying): </small><br /> می‌توانید از Spread Operator برای کپی کردن یک آبجکت به صورت کامل یا اضافه کردن خصوصیت‌های جدید به آبجکت استفاده کنید. به عنوان مثال: <code> const obj1 = { name: 'John', age: 30 }; <br /> const obj2 = { ...obj1, city: 'New York' };<br /> console.log(obj2); // { name: 'John', age: 30, city: 'New York' } </code> Spread Operator یک ویژگی قدرتمند است که کد را خوانا تر و کارآمدتر می‌کند و به برنامه‌نویسان این امکان را می‌دهد تا با کار کردن با داده‌ها به صورت سریعتر و منطقی‌تر، کد های کوتاهتر و خواناتری بنویسند.</p>"
  },
  {
    "title": "24- map و set ؟",
    "answer": "<p>Map و Set دو ساختار داده مهم در جاوااسکریپت هستند که به شما امکان می‌دهند تا داده‌های خود را در یک مجموعه مرتب (Map) یا بدون تکرار (Set) ذخیره کنید و به آن‌ها دسترسی داشته باشید. این دو ساختار داده دارای ویژگی‌ها و کاربردهای متفاوتی هستند: <br /> <span>Map</span> یک مجموعه داده است که از جفت‌های 'کلید-مقدار' تشکیل شده است. به عبارت دیگر، هر عنصر در Map شامل یک کلید و مقدار متناظر است. <br /> کلیدها در یک Map می‌توانند هر نوع داده‌ای (شامل رشته، عدد، شیء و غیره) باشند. <br /> Map تضمین می‌کند که عناصر در آن به ترتیب اضافه شده‌اند و قابلیت حذف، به روزرسانی و جستجو بر اساس کلید را فراهم می‌کند. <br /> برخی از متد‌های مهم Map عبارتند از: set()، get()، has()، delete()، clear()، keys()، values() و entries(). <code> const myMap = new Map(); <br /> myMap.set('key1', 'value1');<br /> myMap.set('key2', 'value2');<br /> console.log(myMap.get('key1')); // 'value1'<br /> console.log(myMap.has('key2')); // true<br /> </code> <span>Set</span> یک مجموعه داده بدون تکرار است که تنها مقادیر منحصر به فرد را در خود ذخیره می‌کند. عناصر در یک Set بدون ترتیب خاصی ذخیره می‌شوند، به عبارت دیگر، ترتیب اضافه شدن آنها مهم نیست. <br /> Set قابلیت اضافه کردن عناصر جدید، حذف عناصر موجود و بررسی وجود عناصر را فراهم می‌کند. <br /> برخی از متد‌های مهم Set عبارتند از: add()، delete()، has() و clear(). <code> const mySet = new Set();<br /> mySet.add('apple');<br /> mySet.add('banana');<br /> mySet.add('apple'); // تکراری، اضافه نمی‌شود<br /> console.log(mySet.has('banana')); // true<br /> console.log(mySet.size); // 2<br /> </code> با استفاده از Map و Set، می‌توانید به راحتی با داده‌های خود کار کنید و عملیات‌های مختلفی از جمله اضافه کردن، حذف، بررسی و دسترسی به داده‌ها را انجام دهید. انتخاب بین استفاده از Map و Set بستگی به نوع داده‌هایی دارد که برنامه شما نیاز دارد و آیا شما نیاز به داشتن کلید-مقدار (Map) دارید یا خیر (Set).</p>"
  },
  {
    "title": "25- مفهوم prototype ؟",
    "answer": "<p>در جاوااسکریپت، هر شیء از یک Prototype (نمونه‌ی اصلی) به عنوان الگویی برای ارث‌بری مشتق می‌کند. Prototype یک شیء دیگر است که دارای ویژگی‌ها و رفتارهایی است که به شیء اصلی ارجاع دارد. به این ترتیب، شیء اصلی (که همچنین به عنوان یک instance نیز شناخته می‌شود) از ویژگی‌ها و رفتارهای موجود در Prototype خود بهره می‌برد. <br /> به طور معمول، اشیاء در جاوااسکریپت از Prototype خود به عنوان الگو استفاده می‌کنند تا ویژگی‌ها و رفتارهای مشترک را به اشتراک بگذارند. این به معنای آن است که اگر یک ویژگی یا متدی در Prototype تغییر کند، تمام اشیاء مشتق شده از آن Prototype نیز به طور خودکار این تغییرات را ارث می‌برند. <br /> برای تعریف یک Prototype، می‌توانید از تابع سازنده‌ی یک شیء یا به صورت مستقیم از ویژگی prototype که در هر تابع در جاوااسکریپت وجود دارد، استفاده کنید. از طریق Prototype، می‌توانید ویژگی‌ها و متدهای مشترک را بین اشیاء به اشتراک بگذارید. <br /> به عنوان مثال: <code> // تعریف یک تابع سازنده به نام Person<br /> function Person(name, age) {<br /> this.name = name;<br /> this.age = age;<br /> }<br /> // اضافه کردن یک متد به Prototype تابع Person<br /> Person.prototype.sayHello = function() {<br /> console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);<br /> }<br /> // ساخت یک شیء از نوع Person<br /> const person1 = new Person('Alice', 30);<br /> const person2 = new Person('Bob', 25);<br /> // فراخوانی متد sayHello بر روی شیء person1<br /> person1.sayHello(); // Hello, my name is Alice and I am 30 years old.<br /> </code> در این مثال، Person.prototype به عنوان Prototype برای شیء‌های ایجاد شده از تابع سازنده‌ی Person استفاده می‌شود. وقتی که متد sayHello به Prototype اضافه می‌شود، تمام اشیاء مشتق شده از تابع Person این متد را به ارث می‌برند و می‌توانند از آن استفاده کنند.</p>"
  },
  {
    "title": "26- constructor function ؟",
    "answer": "<p><strong>تابع سازنده یا Constructor Function</strong> در جاوااسکریپت یک تابع معمولی است که برای ایجاد شیء (یا نمونه) از یک کلاس یا نوع خاص استفاده می‌شود. در واقع، تابع سازنده به عنوان یک الگوی قالب بندی برای ایجاد اشیاء استفاده می‌شود و هنگامی که از کلمه کلیدی new برای فراخوانی تابع استفاده می‌شود، یک شیء جدید از نوع مورد نظر ایجاد می‌شود. <br /> تابع سازنده معمولاً با حروف بزرگ نوشته می‌شود تا به عنوان یک تابع سازنده شناخته شود. <br />(به عنوان مثال: Person، Car، Book و غیره) تا نشان دهند که آنها باید با استفاده از کلمه new برای ایجاد یک شیء جدید صدا زده شوند. <br /> این تابع معمولاً ویژگی‌های و متدهای مربوط به هر شیء را تعیین می‌کند. برای تعریف یک تابع سازنده، می‌توانید از این الگوی ساده استفاده کنید: <code> function Person(name, age) { <br /> this.name = name;<br /> this.age = age;<br /> } <br /> // ساخت یک شیء از نوع Person<br /> const person1 = new Person('Alice', 30);<br /> const person2 = new Person('Bob', 25);<br /> </code> در این مثال، Person یک تابع سازنده است که دو ویژگی name و age را به عنوان ویژگی‌های شیء ایجاد شده (instance) از این کلاس تعریف می‌کند. وقتی <br>new Person('Alice', 30) فراخوانی می‌شود، یک شیء جدید از نوع Person ایجاد می‌شود که ویژگی name آن به 'Alice' و ویژگی age آن به 30 تنظیم می‌شود. <br /> توجه داشته باشید که استفاده از توابع سازنده و ایجاد شیء با استفاده از کلمه کلیدی new یکی از روش‌های ایجاد شیء در جاوااسکریپت است. از این روش برای ایجاد اشیاء با ویژگی‌ها و رفتارهای مشترک استفاده می‌شود.</p>"
  },
  {
    "title": "27- class در جاوااسکریپت ؟",
    "answer": "<p><strong>کلاس‌ها</strong> در جاوااسکریپت یک الگوی نوین برنامه‌نویسی هستند که از نسخه ECMAScript 2015 (یا ES6) معرفی شدند. این قابلیت امکان ایجاد ساختارهای شیء‌گرا و ارث‌بری را در جاوااسکریپت فراهم می‌کند و از طریق آن، کد نوشتن در جاوااسکریپت به صورتی مدرن‌تر و قابل خواندن‌تر می‌شود. <br /> بر خلاف ساختارهای تابعی مانند توابع سازنده و prototype، که گذشته از این امکانات برای شبیه‌سازی کلاس‌ها استفاده می‌شدند، اکنون با معرفی کلاس‌ها، این قابلیت به صورت رسمی در جاوااسکریپت وجود دارد. <br /> یک کلاس در جاوااسکریپت می‌تواند شامل ویژگی‌ها (متغیرها) و روش‌ها (توابع) باشد. می‌توانید یک کلاس را با استفاده از کلمه کلیدی class تعریف کنید. سینتکس عمومی برای تعریف یک کلاس به این شکل است: <code> class ClassName { <br /> constructor(/* parameters */) {<br /> // متغیرها و تنظیمات اولیه<br /> } <br /> method1(/* parameters */) {<br /> // عملیات متدها<br /> } <br /> method2(/* parameters */) {<br /> // عملیات متدها<br /> } <br /> // ویژگی‌ها و متدهای دیگر } </code> در اینجا، constructor یک متد ویژه است که وقتی یک شیء از کلاس ایجاد می‌شود، فراخوانی می‌شود و می‌تواند تنظیمات اولیه شیء را انجام دهد. سایر متدها (method‌ها) نیز عملیات مختلفی را بر روی اشیاء انجام می‌دهند. <br /> مثالی از تعریف یک کلاس در جاوااسکریپت: <code> class Person {<br /> constructor(name, age) {<br /> this.name = name;<br /> this.age = age;<br /> } <br /> sayHello() {<br /> console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);<br /> }<br /> } <br /> const person1 = new Person('Alice', 30);<br /> const person2 = new Person('Bob', 25);<br /> <br /> person1.sayHello(); // Hello, my name is Alice and I am 30 years old. </code> در این مثال، Person یک کلاس است که دو ویژگی name و age را دارد و همچنین یک متد به نام sayHello را که اطلاعات شخص را چاپ می‌کند. با استفاده از new Person()، دو شیء جدید از این کلاس ایجاد می‌شود و متدهای آنها صدا زده می‌شوند.</p>"
  },
  {
    "title": "28- مفهوم ارث بری ؟",
    "answer": "<p><strong>ارث بری</strong> یک مفهوم مهم در برنامه‌نویسی شیء‌گرا است که به شیء‌گرایی امکان می‌دهد تا از ویژگی‌ها و رفتارهای مشترک بین شیء‌ها بهره‌مند شود و کد نویسی مدیریت پذیرتر و کاربردی‌تری را فراهم کند. در ارث بری، یک کلاس (یا شیء) می‌تواند ویژگی‌ها و رفتارهای یک کلاس دیگر را به ارث ببرد و از آنها بهره‌مند شود. <br /> کلاسی که ارث بری انجام می‌دهد، به عنوان کلاس پایه یا superclass (یا همچنین کلاس مادر یا پدر) شناخته می‌شود. و کلاسی که از یک کلاس دیگر به ارث برده می‌شود، به عنوان کلاس مشتق یا subclass (یا همچنین کلاس فرزند) شناخته می‌شود. <br /> با ارث بری، کلاس مشتق از کلاس پایه تمام ویژگی‌ها و روش‌های موجود در کلاس پایه را به ارث می‌برد و می‌تواند آنها را بازنویسی (override) کرده و یا ویژگی‌ها و روش‌های جدیدی را اضافه کند. این کار برای تجزیه و تحلیل کد و جلوگیری از تکرار در برنامه‌نویسی بسیار مفید است. <br /> برای مثال، فرض کنید یک کلاس به نام Animal داریم که دارای ویژگی‌های مشترکی برای تمام حیوانات است مانند نام و سن. حالا فرض کنید که می‌خواهیم یک کلاس Dog بسازیم که حیوانات خاصیت‌هایی مانند رنگ و نوع دارند. می‌توانیم کلاس Dog را از کلاس Animal به ارث ببریم تا از ویژگی‌های مشترک در Animal بهره‌مند شویم و ویژگی‌های خاص خود را نیز به کلاس Dog اضافه کنیم. <br /> مثال کد: <code> class Animal {<br /> constructor(name, age) {<br /> this.name = name;<br /> this.age = age;<br /> } <br /> // متد speak() {<br /> console.log('Animal is speaking');<br /> }<br /> } <br /> class Dog extends Animal {<br /> constructor(name, age, color) {<br /> // فراخوانی constructor کلاس پایه<br /> super(name, age);<br /> this.color = color;<br /> } <br /> // متد overridden speak() {<br /> console.log('Dog is barking');<br /> } <br /> // متد جدید اضافه شده wagTail() {<br /> console.log('Dog is wagging tail');<br /> }<br /> } <br /> // ساخت یک شیء از کلاس Dog const myDog = new Dog('Buddy', 5, 'Brown');<br /> console.log(myDog.name); // 'Buddy'<br /> console.log(myDog.age); // 5<br /> console.log(myDog.color); // 'Brown'<br /> myDog.speak(); // 'Dog is barking'<br /> myDog.wagTail(); // 'Dog is wagging tail'<br /> </code> در این مثال، کلاس Dog از کلاس Animal به ارث برده شده است و ویژگی‌های نام و سن را از Animal به ارث برده است. همچنین متد speak را بازنویسی (override) کرده و متد wagTail را به کلاس Dog اضافه کرده است. <br /> <span>مزایای ارث‌بری شامل موارد زیر است:</span> <br /> <small>باز استفاده از کد:</small> ارث‌بری امکان استفاده مجدد از کد را فراهم می‌کند، زیرا کلاس‌های مشتق می‌توانند ویژگی‌ها و روش‌های کلاس پدر را به صورت مستقیم به ارث ببرند. <br /> <small>سازماندهی کد:</small> ارث‌بری به سازماندهی کد کمک می‌کند، زیرا ارتباطات میان کلاس‌ها را به وضوح نشان می‌دهد و ساختار کد را بهبود می‌بخشد. <br /> <small>گسترش قابلیت‌ها:</small> از طریق ارث‌بری، می‌توان قابلیت‌های جدید به کلاس‌ها اضافه کرد و به این ترتیب کد را گسترش داد.</p>"
  },
  {
    "title": "29- oop چیست ؟",
    "answer": "<p><strong>OOP یا Object-Oriented Programming</strong> به معنی برنامه‌نویسی شیءگرا است. این یک رویکرد برنامه‌نویسی است که بر پایه مفهوم اشیاء (Objects) و ارتباطات بین آنها بنا شده است. در برنامه‌نویسی شیءگرا، داده و عملیات مرتبط با هر شیء به صورت یک واحد مستقل (یا شیء) مدل می‌شوند و این اشیاء با یکدیگر تعامل دارند تا وظایف مختلفی را انجام دهند. <br /> <span>مفاهیم اصلی OOP عبارتند از:</span> <br /> <small>کلاس (Class):</small> یک قالب برای ایجاد اشیاء است. یک کلاس مشخص می‌کند که چه ویژگی‌ها و روش‌هایی (متغیرها و متدها) باید هر شیء از آن داشته باشد. <br /> <small>شیء (Object):</small> نمونه‌ای از یک کلاس است که دارای ویژگی‌ها و روش‌های مشخص شده توسط کلاس مربوطه است. <br /> <small>ویژگی‌ها (Properties):</small> ویژگی‌ها متغیرهای داخلی هر شیء هستند که اطلاعات مربوط به شیء را نگه می‌دارند. <br /> <small>روش‌ها (Methods):</small> روش‌ها عملیاتی هستند که می‌توانند بر روی شیء اجرا شوند و عملکرد و ویژگی‌های شیء را تغییر دهند. <br /> <small>ارث‌بری (Inheritance):</small> فرایندی است که در آن یک کلاس جدید (زیرکلاس) از یک کلاس موجود (پدر یا کلاس ماهر) ایجاد می‌شود و ویژگی‌ها و روش‌های آن را به ارث می‌برد. <br /> <small>پلی‌مورفیسم (Polymorphism): </small>این امکان را فراهم می‌کند که یک روش در کلاس‌های مختلف با همین نام ولی با رفتار متفاوت تعریف شود. <br /> OOP با اینکه به نوعی از برنامه‌نویسی ساختاری متمایز است، اما باعث افزایش قابلیت‌ها، بهبود قابلیت‌های مدیریت کد، افزایش قابلیت استفاده مجدد و بهبود قابلیت توسعه برنامه‌ها می‌شود. به همین دلیل، OOP یکی از محبوب‌ترین رویکردهای برنامه‌نویسی است که در زبان‌های برنامه‌نویسی مختلف، از جمله جاوااسکریپت، استفاده می‌شود.</p>"
  },
  {
    "title": "30- کلمه کلیدی new ؟",
    "answer": "<p>کلمه کلیدی new در جاوااسکریپت برای ایجاد یک نمونه جدید از یک کلاس یا تابع سازنده (Constructor Function) استفاده می‌شود. وقتی شما new را به همراه یک کلاس یا یک تابع سازنده فراخوانی می‌کنید، یک شیء جدید از آن کلاس یا تابع سازنده ایجاد می‌شود و به شما بازگردانده می‌شود. <br /> <span>وظیفه new عبارت است از:</span><br /> <small>ایجاد یک شیء جدید از کلاس یا تابع سازنده. </small><br /> <small> ارتباط برقرار کردن این شیء با کلاس یا تابع سازنده مورد نظر.</small> <br /> <small> بازگرداندن شیء ایجاد شده به شما تا بتوانید از آن استفاده کنید. </small><br /> به طور معمول، زمانی که یک تابع سازنده فراخوانی می‌شود، این تابع یک شیء جدید ایجاد می‌کند و با استفاده از کلمه کلیدی this به آن شیء ارتباط می‌دهد. وقتی شما new را به همراه یک تابع سازنده استفاده می‌کنید، this به اشاره‌گری به شیء جدید تنظیم می‌شود که به عنوان نتیجه ایجاد شده است. <br /> مثال: <code> // تعریف یک تابع سازنده (Constructor Function) <br /> function Person(name, age) {<br /> this.name = name;<br /> this.age = age;<br /> } <br /> // ساخت یک شیء جدید از تابع سازنده با استفاده از new<br /> const person1 = new Person('Alice', 30);<br /> console.log(person1.name); // 'Alice'<br /> console.log(person1.age); // 30<br /> </code> در این مثال، با استفاده از new، یک شیء جدید از تابع سازنده Person ایجاد می‌شود و ویژگی‌های name و age به آن تنظیم می‌شوند. سپس این شیء به عنوان نتیجه بازگردانده می‌شود و ما می‌توانیم از آن استفاده کنیم.</p>"
  },
  {
    "title": "31- template literals چیست ؟",
    "answer": "<p><strong>Template literals</strong> یک ویژگی در جاوااسکریپت است که امکان ایجاد رشته‌های چندخطی و اعمال قوانین فرمت‌بندی به آن‌ها را فراهم می‌کند. این ویژگی از ECMAScript 2015 (یا ES6) معرفی شد و امکان ادغام متغیرها و عبارات JavaScript به صورت مستقیم درون رشته‌ها را فراهم می‌کند. <br /> در template literals، از علامت backtick (`) برای شروع و پایان رشته استفاده می‌شود. سپس می‌توانید متغیرها یا عبارات JavaScript را با استفاده از علامت دلار ($) و علامت آکولاد منحنی ({}) به صورت دلخواه داخل رشته‌ها قرار دهید. <br /> مثال: <code> const name = 'Alice';<br /> const age = 30;<br /> const message = `Hello, my name is ${name} and I am ${age} years old.`;<br /> console.log(message); </code> در این مثال، متغیرهای name و age به صورت مستقیم درون رشته message استفاده شده‌اند. وقتی این رشته را به کنسول چاپ می‌کنیم، متغیرها به مقادیر متناظر خود تبدیل می‌شوند و متن نهایی به شکل زیر خواهد بود: <code> Hello, my name is Alice and I am 30 years old. </code> به علاوه، template literals امکان ایجاد رشته‌های چندخطی را فراهم می‌کند بدون نیاز به استفاده از کاراکترهای جدید خط. به عبارت دیگر، شما می‌توانید رشته‌های چندخطی را بدون استفاده از \n ایجاد کنید. <br /> مثال: <code> const multiline = ` <br /> This is a multiline <br /> string using template literals.<br /> It can span across multiple lines<br /> without the need for escape characters.<br /> `;<br /> console.log(multiline); </code> این روش ایجاد رشته‌های چندخطی به صورت خواناتر و قابل فهم‌تری را فراهم می‌کند، به خصوص زمانی که نیاز به ایجاد رشته‌های طولانی و پیچیده باشد.</p>"
  },
  {
    "title": "32- object destructuring چیست ؟",
    "answer": "<p><strong>Object destructuring</strong> یک قابلیت در جاوااسکریپت است که امکان استخراج مقادیر از یک شیء (Object) را با استفاده از نام‌های ویژگی‌ها (Properties) فراهم می‌کند. این ویژگی از نسخه ECMAScript 2015 (یا ES6) معرفی شده است و به برنامه‌نویسان امکان می‌دهد که به سادگی مقادیر مورد نیاز خود را از یک شیء استخراج کنند و در متغیرها ذخیره کنند. <br /> برای استفاده از Object destructuring، شما از علامت  { } استفاده می‌کنید و داخل آن نام ویژگی‌ها را که می‌خواهید استخراج کنید را مشخص می‌کنید. <br /> <span>نحوه استفاده از object destructuring:</span> <code> const person = {<br /> name: 'Alice',<br /> age: 30,<br /> country: 'USA'<br /> }; <br /> // استخراج ویژگی‌های شیء و انتقال آنها به متغیرها<br /> const { name, age, country } = person;<br /> console.log(name); // 'Alice'<br /> console.log(age); // 30<br /> console.log(country); // 'USA' </code> در این مثال، با استفاده از object destructuring، ما ویژگی‌های name، age و country از شیء person را به متغیرهای متناظر استخراج کرده‌ایم. این به ما این امکان را می‌دهد که به صورت مستقیم بر روی این ویژگی‌ها کار کنیم، بدون اینکه نیازی به استفاده از نام شیء (person.name) داشته باشیم. <br /> همچنین می‌توانید با استفاده از object destructuring در پارامترهای توابع نیز ویژگی‌های شیء را استخراج کنید: <code> function printPersonInfo({ name, age, country }) {<br /> console.log(`Name: ${name}, Age: ${age}, Country: ${country}`);<br /> } <br /> printPersonInfo(person); // Output: Name: Alice, Age: 30, Country: USA </code> در این مثال، تابع printPersonInfo ویژگی‌های name، age و country را از شیء ورودی استخراج کرده و مقادیر آن‌ها را نمایش می‌دهد. استفاده از object destructuring اینجا به صورتی کد را کوتاه و خواناتر می‌کند.</p>"
  },
  {
    "title": "33- تفاوت filter و find ؟",
    "answer": "<p>توابع filter و find هر دو در جاوااسکریپت برای جستجو و فیلتر کردن موارد در آرایه‌ها استفاده می‌شوند، اما تفاوت اصلی آنها در نحوه عملکرد و نتیجه بازگشتی آنها است. <br /> <span>filter</span> یک آرایه را می‌گیرد و یک آرایه جدیدی ایجاد می‌کند که شامل تمام مواردی است که شرط داده شده برای آنها درست باشد. اگر شرطی برای موارد مورد نظر وجود داشته باشد، آن موارد در آرایه نهایی حضور خواهند داشت. اگر شرطی برای موارد مورد نظر وجود نداشته باشد، آرایه خالی به عنوان نتیجه برگردانده می‌شود. <br /> <small>مثال:</small> <code> const numbers = [1, 2, 3, 4, 5];<br /> const evenNumbers = numbers.filter(num => num % 2 === 0);<br /> console.log(evenNumbers); // Output: [2, 4]<br /> </code> در این مثال، filter از آرایه numbers استفاده کرده و اعداد زوج را از آن فیلتر کرده و به عنوان نتیجه، آرایه [2, 4] را برمی‌گرداند. <br /> <span>find </span>نیز یک آرایه را می‌گیرد و اولین موردی را که شرط داده شده برای آن درست باشد، برمی‌گرداند. اگر موردی با شرط داده شده یافت نشود، undefined برگردانده می‌شود. <br /> <small>مثال:</small> <code> const fruits = ['apple', 'banana', 'cherry', 'orange'];<br /> const cherryIndex = fruits.find(fruit => fruit === 'cherry');<br /> console.log(cherryIndex); // Output: cherry </code> در این مثال، find از آرایه fruits استفاده کرده و اولین موردی که با مقدار 'cherry' همخوانی دارد را برمی‌گرداند که در اینجا مقدار 'cherry' است. <br /> بنابراین، تفاوت اصلی بین filter و find در نتیجه بازگشتی آنها است. filter یک آرایه از موارد را برمی‌گرداند در حالی که find فقط اولین مورد یافت شده را برمی‌گرداند یا undefined اگر موردی یافت نشود.</p>"
  },
  {
    "title": "34- ویژگی های arrow function ؟",
    "answer": "<p>توابع Arrow functions یک ویژگی مهم و معمولاً مورد استفاده در جاوااسکریپت هستند که در ES6 (ECMAScript 2015) معرفی شدند. این نوع توابع به شما اجازه می‌دهند تا توابع کوتاه را به صورت خلاصه‌تر و با نحوی کوتاه‌تر نوشته و استفاده کنید. ویژگی‌های مهم Arrow functions عبارتند از: <br /> <small>سینتکس کوتاه‌تر</small>: سینتکس arrow function به صورت کوتاه‌تر و خواناتری نسبت به توابع معمولی ارائه می‌شود. این کوتاهی‌ها باعث افزایش خوانایی کد می‌شوند. <code> // تابع معمولی<br /> function add(a, b) {<br /> return a + b;<br /> } <br /> // تابع Arrow<br /> const add = (a, b) => a + b; </code> <small>عدم نیاز به کلمه کلیدی function:</small> در arrow function، نیازی به استفاده از کلمه کلیدی function برای تعریف تابع نیست. این به شما اجازه می‌دهد که کد را با حذف کلمه اضافی کوتاه‌تر کنید. <br /> <small>بدنه‌ی انتزاعی:</small> اگر بدنه‌ی تابع تنها شامل یک عبارت باشد، می‌توانید آن را بدون استفاده از کلمه کلیدی return و با عدم نیاز به {} نوشته و مقدار آن به صورت ضمنی بازگردانید. <br /> <small>عدم تغییر مقدار this:</small> توابع arrow عملکرد this را به صورت لغوشدنی ندارند و مقدار this در داخل آنها به this محیط خارجی متصل می‌شود. <code> const person = {<br /> name: 'Alice',<br /> age: 30,<br /> greet: function() {<br /> console.log(`Hello, my name is ${this.name}`);<br /> }<br /> }; <br /> person.greet(); // Output: Hello, my name is Alice // استفاده از تابع Arrow<br /> const person = {<br /> name: 'Alice',<br /> age: 30,<br /> greet: () => {<br /> console.log(`Hello, my name is ${this.name}`); // 'this' به محیط خارجی متصل می‌شود<br /> }<br /> }; <br /> person.greet(); // Output: Hello, my name is undefined </code> <small>عدم ایجاد arguments: </small>توابع arrow arguments خود را ندارند. اگر به متغیر arguments در داخل یک arrow function نیاز دارید، باید از توابع معمولی استفاده کنید. <br /> <small>عدم قابلیت استفاده به عنوان constructor: </small>توابع arrow نمی‌توانند به عنوان کانستراکتورها (برای ایجاد شیء جدید) استفاده شوند. این به این معناست که نمی‌توانید از new برای ایجاد شیء جدید از یک arrow function استفاده کنید. <code> // تابع معمولی<br /> function Person(name) {<br /> this.name = name;<br /> } <br /> const alice = new Person('Alice'); // کار می‌کند <br /> // تابع Arrow <br /> const Person = (name) => {<br /> this.name = name; // اینجا با خطا مواجه می‌شویم<br /> } <br /> const alice = new Person('Alice'); // TypeError: Person is not a constructor <br /> </code> <code> function myFunc() {<br /> console.log(arguments); // متغیر arguments<br /> } <br /> myFunc(1, 2, 3); // Output: [1, 2, 3]<br /> <br /> const myArrowFunc = () => {<br /> console.log(arguments); // undefined (نداریم)<br /> } <br /> myArrowFunc(1, 2, 3); // Output: Uncaught ReferenceError: arguments is not defined </code> <small>مناسب برای کار با کالبک‌ها و Promise‌ها: </small>ازarrow function به خوبی می‌توانید برای تعریف کالبک‌ها و استفاده از Promise‌ها در جاوااسکریپت استفاده کنید، زیرا کد به صورت متناهی کوتاه‌تر و خواناتری نوشته می‌شود. <br /> <code> // تعریف arrow function<br /> const add = (a, b) => a + b;<br /> // استفاده از arrow function به عنوان کالبک<br /> setTimeout(() => {<br /> console.log('Timer finished');<br /> }, 1000); <br /> // استفاده از arrow function در Promise<br /> const myPromise = new Promise((resolve, reject) => {<br /> // انجام محاسبات<br /> resolve(result);<br /> }); </code> در این مثال، arrow function برای تعریف تابع add، کالبکی برای setTimeout و تابعی برای ایجاد یک Promise استفاده شده است، که کد را خواناتر و کوتاه‌تر می‌کند.</p>"
  },
  {
    "title": "35- تفاوت های map و forEach ؟",
    "answer": "<p>توابع map و forEach هر دو برای اجرای عملیات بر روی هر عنصر در یک آرایه در جاوااسکریپت استفاده می‌شوند، اما تفاوت‌های مهمی در عملکرد و نحوه استفاده از آن‌ها وجود دارد: <br /> <small>forEach</small> یک تابع است که برای هر عنصر در آرایه فراخوانی می‌شود و برای هر عنصر، یک عملیات مشخص اعمال می‌کند. <br /> <small>forEach</small> هیچ مقدار بازگشتی ندارد و فقط عملیات مشخص شده را بر روی هر عنصر انجام می‌دهد. <br /> <small>forEach</small> از اصلیت مقدارهای آرایه استفاده می‌کند و هیچ تغییری در مقدار آرایه اصلی ایجاد نمی‌کند. <br /> مثال: <code> const numbers = [1, 2, 3, 4];<br /> numbers.forEach(num => console.log(num * 2));<br /> // Output:<br /> // 2 // 4 // 6 // 8 </code> <small>map</small> نیز برای هر عنصر در آرایه فراخوانی می‌شود، اما به جای اینکه تغییری را در آرایه اصلی انجام دهد، یک آرایه جدیدی را ایجاد می‌کند که شامل نتایج عملیات مشخص شده بر روی هر عنصر است. <br /> <small>map</small> یک آرایه جدید با مقدار‌های تغییر یافته را باز می‌گرداند و مقدار آرایه اصلی را تغییر نمی‌دهد. <br /> <small>map</small> از اصلیت مقدارهای آرایه استفاده می‌کند و نتایج عملیات را در یک آرایه جدید برمی‌گرداند. <br /> مثال: <code> const numbers = [1, 2, 3, 4];<br /> const doubledNumbers = numbers.map(num => num * 2);<br /> console.log(doubledNumbers); // Output: [2, 4, 6, 8] </code> بنابراین، تفاوت اصلی بین forEach و map در این است که forEach فقط برای اجرای یک عملیات بر روی هر عنصر استفاده می‌شود، در حالی که map برای ایجاد یک آرایه جدید با نتایج عملیات بر روی هر عنصر استفاده می‌شود.</p>"
  },
  {
    "title": "36- تفاوت mutable و immutable ؟",
    "answer": "<p>مفهوم Mutable و Immutable در برنامه‌نویسی به روشی که داده‌ها در حافظه مدیریت می‌شوند ارتباط دارد: <br /> <span>Mutable:</span> اگر یک داده قابل تغییر یا Mutable باشد، این به معنای این است که می‌توانید مقادیر آن را در محلی که داده ذخیره شده تغییر دهید. <br /> در داده‌های Mutable، می‌توانید ویژگی‌ها یا مقادیر داخلی را برای یک شیء یا داده تغییر دهید بدون ایجاد یک نسخه جدید. <br /> <span>Immutable:</span> اگر یک داده غیرقابل تغییر یا Immutable باشد، این به معنای این است که شما نمی‌توانید مقادیر آن را بعد از ایجاد تغییر کنید. <br /> در داده‌های Immutable، مقادیر آنها پس از ایجاد ثابت می‌مانند و تغییری روی آنها اعمال نمی‌شود، به جای آن یک نسخه جدید ایجاد می‌شود. <br /> <small>به عنوان مثال،</small> در جاوااسکریپت، رشته‌ها (Strings) و اعداد (Numbers) از نوع Immutable هستند. این به معنای این است که شما نمی‌توانید مقادیر رشته‌ها یا اعداد را مستقیماً در محلی که در حافظه ذخیره شده‌اند تغییر دهید. به جای آن، برای تغییر رشته یا عدد، یک نسخه جدید از آنها ایجاد می‌شود. <br />از طرف دیگر، آرایه‌ها و اشیاء در جاوااسکریپت Mutable هستند، به این معنا که می‌توانید مقادیر درون آنها را تغییر دهید بدون ایجاد یک نسخه جدید. تفاوت اصلی بین این دو مفهوم این است که mutable به معنای امکان تغییر داده‌ها می‌باشد، در حالی که immutable به معنای عدم امکان تغییر داده‌ها است. استفاده از داده‌های immutable معمولاً باعث کاهش اشکالات و خطاهایی مانند side effects و race conditions می‌شود، زیرا داده‌های immutable برای همیشه ثابت هستند و هیچ تغییر ناخواسته‌ای روی آنها اعمال نمی‌شود.</p>"
  },
  {
    "title": "37- روش های ترکیب دو آرایه ؟",
    "answer": "<p>ترکیب دو آرایه به معنای ادغام یا اتصال دو آرایه به یکدیگر است. در جاوااسکریپت، شما می‌توانید از چندین روش برای انجام این کار استفاده کنید. در ادامه، چندین روش برای ترکیب دو آرایه را معرفی می‌کنم: <br /> این روش از تابع <small>concat()</small> برای اتصال دو آرایه استفاده می‌کند. این تابع یک آرایه جدید ایجاد می‌کند که شامل تمام عناصر آرایه اول و سپس تمام عناصر آرایه دوم است. <code> const arr1 = [1, 2, 3];<br /> const arr2 = [4, 5, 6];<br /> const combinedArray = arr1.concat(arr2);<br /> console.log(combinedArray); // Output: [1, 2, 3, 4, 5, 6] </code> شما می‌توانید از <small>spread operator(...)</small> برای ادغام دو آرایه استفاده کنید. این اپراتور تمام عناصر یک آرایه را جداگانه استخراج کرده و آنها را در مکانی که استفاده می‌کنید قرار می‌دهد. <code> const arr1 = [1, 2, 3];<br /> const arr2 = [4, 5, 6];<br /> const combinedArray = [...arr1, ...arr2];<br /> console.log(combinedArray); // Output: [1, 2, 3, 4, 5, 6] </code> این روش می‌تواند برای اضافه کردن تمام عناصر یک آرایه به آرایه دیگر استفاده شود. برای استفاده از <small>push()</small>، تمام عناصر آرایه دوم به آرایه اول اضافه می‌شوند. برای استفاده از <small>unshift()</small>، تمام عناصر آرایه دوم به ابتدای آرایه اول اضافه می‌شوند. <code> const arr1 = [1, 2, 3];<br /> const arr2 = [4, 5, 6];<br /> arr1.push(...arr2); // or arr1.unshift(...arr2);<br /> console.log(arr1); // Output: [1, 2, 3, 4, 5, 6] </code> شما همچنین می‌توانید تابع <small>concat()</small> را در داخل <small>push()</small> یا <small>unshift()</small> برای ترکیب دو آرایه استفاده کنید. <code> const arr1 = [1, 2, 3]; <br /> const arr2 = [4, 5, 6];<br /> arr1.push(...arr2.concat()); // or arr1.unshift(...arr2.concat());<br /> console.log(arr1); // Output: [1, 2, 3, 4, 5, 6] </code> شما می‌توانید از متد <small>push() </small>برای اضافه کردن عناصر آرایه دوم به آرایه اول استفاده کنید و سپس از <small>apply()</small> برای اعمال تغییرات به آرایه استفاده کنید. <code> const array1 = [1, 2, 3];<br /> const array2 = [4, 5, 6];<br /> Array.prototype.push.apply(array1, array2);<br /> console.log(array1); // Output: [1, 2, 3, 4, 5, 6] </code> همه این روش‌ها به شما امکان می‌دهند دو آرایه را ترکیب کنید و یک آرایه جدیدی که حاوی همه عناصر است را ایجاد کنید. به علاوه، شما می‌توانید از این روش‌ها برای ترکیب بیش از دو آرایه هم استفاده کنید.</p>"
  },
  {
    "title": "38- تفاوت truthy و falsy ؟",
    "answer": "<p>Truthy و Falsy دو واژه است که در جاوااسکریپت برای توصیف مقادیری استفاده می‌شوند که به ترتیب به عنوان صحیح یا غلط شناخته می‌شوند. این مفاهیم به طور خاص در مواردی مانند شرط‌ها و ارزیابی برای صحت داده‌ها استفاده می‌شوند. دقیقاً چه مقادیری به عنوان truthy شناخته می‌شوند و چه مقادیری به عنوان falsy معرفی می‌شوند، به شرح زیر است: <br /> <span>Truthy:</span> <br /> مقادیری که به عنوان صحیح شناخته می‌شوند و موجب اجرای شرط‌های صحیح می‌شوند. این مقادیر عبارتند از:<br /> هر مقدار غیرصفری (به جز 0)<br /> رشته‌های غیرخالی<br /> آرایه‌ها<br /> شیء‌ها<br /> مقادیری که به عنوان true تعیین شده‌اند <br /> <span>Falsy:</span> <br /> مقادیری که به عنوان غلط شناخته می‌شوند و موجب اجرای شرط‌های غلط می‌شوند. این مقادیر عبارتند از:<br /> false<br /> null<br /> undefined<br /> 0<br /> NaN<br /> رشته‌های خالی (' ') <br /> <br />وقتی یک شرط در جاوااسکریپت ارزیابی می‌شود، مقداری که به عنوان شرط ارسال می‌شود، به یکی از این دو دسته تعلق می‌گیرد. به عنوان مثال، اگر یک شرط مقداری را از یک متغیر مشخص کند و این متغیر رشته‌ای خالی باشد، شرط به عنوان falsy شناخته می‌شود و شرط به عنوان غلط ارزیابی می‌شود. از طرف دیگر، اگر مقدار متغیری غیرخالی و غیرصفری باشد، شرط به عنوان truthy شناخته می‌شود و به عنوان صحیح ارزیابی می‌شود.</p>"
  },
  {
    "title": "39- تفاوت حلقه for...of و for...in ؟",
    "answer": "<p>تفاوت اصلی بین حلقه for...of و for...in در جاوااسکریپت در نحوه ارتباط با عناصر یک آرایه یا شیء و نحوه گردش در آنها است. <br /> حلقه <small>for...of</small> برای گردش در عناصر یک iterable مانند آرایه‌ها، رشته‌ها، Mapها، Setها و سایر موارد مشابه استفاده می‌شود. <br /> این حلقه عناصر آرایه (یا دیگر iterable ها) را از ابتدا تا انتها در ترتیبی که در آرایه وجود دارد، یک به یک گردش می‌دهد. <br /> برای هر مورد در آرایه، شیء یا دیگر iterable، یک بار محتویات آن به عنوان مقدار متغیر مورد نظر (مانند یک متغیر معین در بلاک حلقه) قرار می‌گیرد. مثال: <code> const numbers = [1, 2, 3];<br /> for (const num of numbers) {<br /> console.log(num); // Output: 1, 2, 3<br /> } </code> حلقه <small>for...in</small> برای گردش در ویژگی‌های enumerable یک شیء (object) استفاده می‌شود. این حلقه برای هر ویژگی enumerable در شیء، نام ویژگی (یا کلید) را به عنوان مقدار متغیر مورد نظر قرار می‌دهد. <br /> توجه داشته باشید که for...in عموماً برای گردش در ویژگی‌های شیء‌ها استفاده می‌شود، نه برای گردش در عناصر آرایه‌ها. یکی از مشکلات این حلقه این است که به صورت پیش فرض نمایه‌های مرتب‌شده عددی نیز شامل می‌شود. <br /> مثال: <code> const person = {<br /> name: 'John',<br /> age: 30<br /> }; <br /> for (const key in person) {<br /> console.log(key); // Output: 'name', 'age'<br /> console.log(person[key]); // Output: 'John', 30<br /> } </code> بنابراین، اگر شما می‌خواهید برای گردش در مقادیر یک آرایه، از for...of استفاده کنید، و اگر می‌خواهید برای گردش در ویژگی‌های یک شیء، از for...in استفاده کنید.</p>"
  },
  {
    "title": "40- لایبری‌ها در جاوااسکریپت ؟",
    "answer": "<p><strong>لایبری‌ها (یا کتابخانه‌ها)</strong> در جاوااسکریپت مجموعه‌ای از کدها و عملکردهای آماده‌ای هستند که توسط توسعه‌دهندگان ایجاد شده‌اند و معمولاً برای حل یک مسئله خاص یا ارائه یک قابلیت خاص مورد استفاده قرار می‌گیرند. این کتابخانه‌ها به شما اجازه می‌دهند که از کدهای آماده دیگران استفاده کرده و زمان و تلاش خود را برای ایجاد کدهای مشابه کاهش دهید. <br /> <span>در زیر چند نمونه از معروفترین کتابخانه‌های جاوااسکریپت ذکر شده است:</span> <br /> <small>jQuery:</small> یکی از محبوب‌ترین کتابخانه‌های جاوااسکریپت که برای انجام عملیات DOM و برنامه‌نویسی ایجاد رابط کاربری (UI) استفاده می‌شود. <br /> <small>React:</small> یک کتابخانه محبوب جاوااسکریپت برای ساخت رابط کاربری (UI) تعاملی است که توسط Facebook توسعه داده شده است. <br /> <small>Vue.js:</small> یک چارچوب جاوااسکریپت برای ساخت رابط کاربری تعاملی و تک‌صفحه‌ای است که به طور کامل قابل توسعه است. <br /> <small>Angular:</small> یک چارچوب جاوااسکریپت توسعه داده شده توسط Google برای توسعه برنامه‌های تک‌صفحه‌ای و وب‌اپلیکیشن‌های تعاملی. <br /> <small>Lodash:</small> یک کتابخانه مفید که شامل توابع کاربردی برای کار با آرایه‌ها، رشته‌ها، اشیاء و سایر داده‌ساختارها در جاوااسکریپت است. <br /> <small>Moment.js:</small> یک کتابخانه برای کار با تاریخ و زمان در جاوااسکریپت که قابلیت فرمت‌بندی، تبدیل و عملیات روی تاریخ و زمان را فراهم می‌کند. <br /> <small>Express.js:</small> یک چارچوب سمت سرور جاوااسکریپت برای توسعه برنامه‌های وب سمت سرور است که بر پایه Node.js استوار است. <br /> <small>D3.js:</small> یک کتابخانه برای ایجاد ویژوالیزیشن‌های داده در وب است که از HTML، SVG و CSS برای ایجاد نمودارها و نمایش داده‌ها استفاده می‌کند. <br /><br /> همچنین، وجود مخازن کد مانند npm و yarn به توسعه‌دهندگان اجازه می‌دهد که از هزاران کتابخانه و پکیج مفید دیگر در جاوااسکریپت استفاده کنند. این مخازن از جمله منابع اصلی برای پیدا کردن کتابخانه‌های جدید و مفید برای پروژه‌های جاوااسکریپت هستند.</p>"
  },
  {
    "title": "41- تفاوت deep copy و shallow copy ؟",
    "answer": "<p>تفاوت اصلی بین deep copy (کپی عمیق) و shallow copy (کپی سطحی) در جاوااسکریپت مربوط به این است که چگونه داده‌های تودرتو (nested) در کپی شده‌ها مورد پردازش قرار می‌گیرند: <br /> <span>Shallow Copy (کپی سطحی):</span><br /> در shallow copy، فقط مراجع به داده‌های اولیه کپی می‌شوند، به این معنی که تنها آدرس یا شناسه داده‌های اصلی در حافظه کپی می‌شود. <br /> در صورتی که داده‌ها چند‌بعدی باشند، فقط آدرس یا شناسه اولیه این داده‌ها کپی می‌شود و داده‌های داخلی آنها تغییر نمی‌کنند. <br /> اگر یکی از زیرمجموعه‌های shallow copy تغییر کند، این تغییرات در داده اصلی نیز تاثیر می‌گذارد. <br /> روش‌هایی مانند Object.assign() یا spread operator (...) برای ایجاد shallow copy استفاده می‌شوند. <br /> <span>Deep Copy (کپی عمیق):</span> <br /> در deep copy، تمام سطوح و زیرمجموعه‌های داده‌ها نیز کپی می‌شوند، به این معنی که تمام داده‌ها به صورت جداگانه در حافظه ذخیره می‌شوند. <br /> این بدان معناست که تغییرات در داده‌های کپی شده هیچ تاثیری بر داده اصلی ندارد و برعکس.<br /> این نوع کپی به داده‌ساختارهای چند‌بعدی و تو در تو نیز تعمیم داده می‌شود.<br /> برای ایجاد deep copy می‌توان از روش‌هایی مانند بازگشتی یا استفاده از کتابخانه‌های مخصوص deep copy مانند lodash.cloneDeep() استفاده کرد. <br /> <br />با توجه به این تفاوت‌ها، انتخاب بین کپی عمیق و سطحی وابسته به نیازها و موارد استفاده شماست. در برنامه‌هایی که نیاز به ایجاد یک کپی کامل و مستقل از داده‌ها دارید، معمولاً از کپی عمیق استفاده می‌شود. اما اگر تنها نیاز به یک نسخه سریع و ساده از داده‌ها باشد و تغییرات ناخواسته در داده‌های تودرتو مورد توجه نباشد، ممکن است از کپی سطحی استفاده شود.</p>"
  },
  {
    "title": "42- تفاوت bom و dom ؟",
    "answer": "<p>BOM و DOM دو اجزای اصلی محیط مرورگر وب در جاوااسکریپت هستند، اما هر کدام وظایف و مسئولیت‌های متفاوتی دارند: <br /> <span>BOM (Browser Object Model):</span><br /> BOM مربوط به تعامل با مرورگر و سیستم عامل کاربر است. <br /> این مدل شامل ویژگی‌ها و توابعی مانند مدیریت پنجره‌ها، کنسول مرورگر، تاریخ و زمان، محل قرارگیری و اندازه پنجره مرورگر، ناحیه ایمنی و غیره است.<br /> <small>مثال: </small>window.open(), window.close(), window.location, window.alert() و غیره. <br /> <span>DOM (Document Object Model):</span><br /> DOM مربوط به ساختار مستندات HTML یا XML و تعامل با المان‌های آن است.<br /> این مدل شامل ویژگی‌ها و توابعی مانند ایجاد، حذف، اصلاح و مدیریت المان‌های HTML مانند المان‌های div، p، span و غیره است.<br /> DOM یک درخت سلسله مراتبی از المان‌ها را ایجاد می‌کند که به شما امکان می‌دهد به صورت دینامیک محتوا و نمایش صفحه وب را تغییر دهید.<br /> <small>مثال: </small> document.createElement(), element.appendChild(), element.innerHTML, element.style و غیره.<br /> به طور خلاصه، BOM مربوط به مرورگر و قابلیت‌های آن است، در حالی که DOM مربوط به ساختار و محتوای صفحه وب است. در حالی که BOM کنترل مرورگر را فراهم می‌کند، DOM کنترل محتوای وب‌سایت را فراهم می‌کند و به توسعه‌دهندگان اجازه می‌دهد تا با این محتوا تعامل کنند و آن را تغییر دهند.</p>"
  },
  {
    "title": "43- event ها در جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، رویدادها (Events) نشان دهنده عملیاتی هستند که توسط کاربر یا محیط مرورگر انجام می‌شوند، مانند کلیک کردن بر روی یک المان، وارد کردن موس به المان، فشردن کلیدهای صفحه کلید و غیره. رویدادها به توسعه‌دهندگان اجازه می‌دهند تا به واکنش‌های مختلفی که در طول تعامل با کاربر یا محیط رخ می‌دهد، پاسخ دهند. <br /> برخی از مهم‌ترین رویدادها در جاوااسکریپت عبارتند از:<br /> <span>رویدادهای مرورگر (Browser Events):</span> <br /> <small>load:</small> زمانی که صفحه وب یا تمام منابع آن بارگذاری می‌شود.<br /> <small>unload:</small> زمانی که کاربر از صفحه خارج می‌شود.<br /> <small>resize:</small> زمانی که اندازه پنجره مرورگر تغییر می‌کند.<br /> <small>scroll:</small> زمانی که کاربر صفحه را پیمایش می‌کند. و غیره.<br /> <span>رویدادهای فرم (Form Events):</span> <br /> <small>submit:</small> زمانی که فرم ارسال می‌شود.<br /> <small>reset:</small> زمانی که فرم بازنشانی می‌شود.<br /> <small>focus:</small> زمانی که یک المان فرم فعال می‌شود.<br /> <small>blur:</small> زمانی که یک المان فرم از فوکوس خارج می‌شود. و غیره.<br /> <span>رویدادهای کلید (Keyboard Events):</span> <br /> <small>keydown:</small> زمانی که یک کلید صفحه کلید فشرده می‌شود.<br /> <small>keyup:</small> زمانی که یک کلید صفحه کلید رها می‌شود.<br /> <small>keypress:</small> زمانی که یک کلید صفحه کلید فشرده می‌شود و رها می‌شود. و غیره.<br /> <span>رویدادهای موس (Mouse Events):</span> <br /> <small>click:</small> زمانی که یک المان با استفاده از ماوس کلیک می‌شود.<br /> <small>mouseover:</small> زمانی که ماوس بر روی یک المان می‌رود.<br /> <small>mouseout:</small> زمانی که ماوس از روی یک المان خارج می‌شود.<br /> <small>mousemove:</small> زمانی که ماوس در حال حرکت است. و غیره.<br /><br /> برای پیاده‌سازی و پاسخ به این رویدادها، توسعه‌دهندگان معمولاً از متدها و ویژگی‌های موجود در DOM مانند addEventListener و on[event] استفاده می‌کنند. با استفاده از این متدها و ویژگی‌ها، می‌توانید توابعی را به رویدادها متصل کنید و پس از وقوع رویداد، اقدامات مناسبی را انجام دهید.</p>"
  },
  {
    "title": "44- کاربرد preventDefault چیست ؟",
    "answer": "<p><strong>متد preventDefault()</strong> در جاوااسکریپت برای متوقف کردن عمل پیش‌فرضی که توسط یک رویداد انجام می‌شود، استفاده می‌شود. این متد بیشتر در کنترل رفتارهای پیش‌فرض مرورگر در واکنش به رویدادها مورد استفاده قرار می‌گیرد. به طور کلی، کاربرد preventDefault() به شما این امکان را می‌دهد که رفتار پیش‌فرض مرورگر را لغو کرده و عمل مورد نظر خود را در پاسخ به رویداد انجام دهید. <br /> <span>بعضی از کاربردهای متد preventDefault() عبارتند از:</span><br /> <small>لغو ارسال فرم:</small> وقتی کاربر فرمی را ارسال می‌کند، با فراخوانی preventDefault() در رویداد submit می‌توانید ارسال فرم را لغو کنید و اطلاعات را به طور دلخواه پردازش کنید. <br /> <small>لغو کلیک بر روی لینک:</small> با استفاده از preventDefault() می‌توانید از انتقال به آدرس مقصد لینک جلوگیری کنید و به جای آن، عملیات دلخواه خود را انجام دهید، مانند اجرای یک عملیات AJAX. <br /> <small>لغو رفتارهای پیش‌فرضی در واکنش به رویدادهای کلیدی:</small> برای مثال، می‌توانید از preventDefault() برای جلوگیری از عملکرد پیش‌فرضی مرورگر برای کلیدهای خاص مانند کلید Enter در یک فرم استفاده کنید و به جای آن رفتار دیگری را تعیین کنید. <br /> در کل، استفاده از preventDefault معمولاً در صورتی مناسب است که نخواهید که مرورگر به طور پیش‌فرض عملیاتی را انجام دهد و خودتان می‌خواهید عملکرد رویداد را کنترل کنید.</p>"
  },
  {
    "title": "45- انواع سلکتورها در جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، شما می‌توانید از انواع مختلفی از سلکتورها برای انتخاب المان‌های HTML استفاده کنید. این سلکتورها به شما امکان می‌دهند تا المان‌های مورد نظر خود را در DOM (مدل شیء سند) انتخاب کنید تا بتوانید با آنها تعامل داشته و تغییراتی روی آنها اعمال کنید. در زیر به برخی از انواع معمول سلکتورها اشاره شده است: <br /> <span>انتخاب بر اساس نوع المان (Tag Name): </span> <br /> می‌توانید المان‌هایی که با یک نام تگ خاص ایجاد شده‌اند را انتخاب کنید. <code> document.getElementsByTagName('tagname'); </code> <span>انتخاب بر اساس شناسه (ID):</span><br /> می‌توانید المانی که دارای یک شناسه یکتا است را با استفاده از نام شناسه آن انتخاب کنید. <code> document.getElementById('idname'); </code> <span>انتخاب بر اساس کلاس (Class):</span><br /> می‌توانید المان‌هایی که دارای یک یا چند کلاس خاص هستند را با استفاده از نام کلاس آن‌ها انتخاب کنید. <code> document.getElementsByClassName('classname'); </code> <span>انتخاب بر اساس نام (Name):</span> <br /> می‌توانید المان‌هایی که دارای یک نام خاص هستند را با استفاده از نام آن‌ها انتخاب کنید. این عموماً برای المان‌های فرم مانند فیلدهای ورودی (input) استفاده می‌شود. <code> document.getElementsByName(input) </code> <span>انتخاب بر اساس نام CSS Selector: </span> <br /> با استفاده از querySelector() می‌توانید المان‌ها را بر اساس نام CSS انتخاب کنید: <code> document.querySelector('.classname'); // برای انتخاب اولین المان با کلاس مشخص<br /> document.querySelector('#idname'); // برای انتخاب المان با شناسه مشخص<br /> document.querySelector('tagname'); // برای انتخاب اولین المان با نام تگ مشخص<br /> </code> همچنین از querySelectorAll() برای انتخاب تمام المان‌هایی با یک سلکتور خاص استفاده می‌شود: <code> document.querySelectorAll('.classname'); // انتخاب تمام المان‌های با کلاس مشخص </code> <span>انتخاب بر اساس ویژگی‌ها (Attribute Selectors): </span><br /> انتخاب المان‌ها بر اساس ویژگی‌های آنها مانند href، src و غیره: <code> document.querySelector('[href='link']'); // انتخاب المان با ویژگی href </code> <span>انتخاب پدر و فرزندان (Parent and Child Selection): </span><br /> می‌توانید المان‌ها را بر اساس رابطه والدین و فرزندان انتخاب کنید: <code> parentElement.querySelector('.classname'); // انتخاب المان‌ها درون یک والد </code> این تنها چند نمونه از سلکتورهایی هستند که در جاوااسکریپت استفاده می‌شوند. با استفاده از این سلکتورها، می‌توانید المان‌های مورد نظر خود را در DOM انتخاب کرده و با آنها تعامل داشته و تغییراتی روی آنها اعمال کنید.</p>"
  },
  {
    "title": "46- تغییر در محتوای صفحه ؟",
    "answer": "<p>برای انجام تغییرات در محتوای صفحه وب با استفاده از جاوااسکریپت، می‌توانید از متدها و ویژگی‌های DOM استفاده کنید. در زیر چند نمونه از تغییرات رایج در محتوای صفحه با استفاده از جاوااسکریپت آورده شده است: <br /> <span>تغییر متن یا محتوا:</span><br /> برای تغییر متن یا محتوای یک المان می‌توانید از ویژگی textContent یا innerHTML استفاده کنید. <code> // تغییر متن یک المان<br /> document.getElementById('elementId').textContent = 'New Text';<br /> // تغییر محتوای HTML یک المان<br /> document.getElementById('elementId').innerHTML = '<em>New Content</em>'; <br /> // با استفاده از متد innerText <br /> document.getElementById('myElement').innerText = 'New Text'; </code> <span>تغییر ویژگی‌ها:</span><br /> می‌توانید ویژگی‌های یک المان مانند class، src، href و غیره را تغییر دهید. <code> // تغییر کلاس یک المان<br /> document.getElementById('elementId').className = 'newClass';<br /> // تغییر مقدار src یک تصویر<br /> document.getElementById('imageId').src = 'newImage.jpg'; </code> <span>اضافه کردن یا حذف المان‌ها:</span><br /> می‌توانید المان‌های جدید را به DOM اضافه کنید یا المان‌های موجود را حذف کنید. <code> // اضافه کردن یک المان جدید به DOM<br /> var newElement = document.createElement('div');<br /> newElement.textContent = 'New Element';<br /> document.body.appendChild(newElement);<br /> // حذف یک المان موجود<br /> var elementToRemove = document.getElementById('elementId');<br /> elementToRemove.parentNode.removeChild(elementToRemove); </code> <span>استفاده از سلکتورها برای انتخاب المان‌ها:</span><br /> استفاده از سلکتورها برای انتخاب المان‌ها و سپس اعمال تغییرات مورد نظر. <code> // تغییر متن المان‌های با کلاس مشخص<br /> var elements = document.querySelectorAll('.classname');<br /> elements.forEach(function(element) {<br /> element.textContent = 'New Text';<br /> }); </code> با استفاده از این روش‌ها، می‌توانید به راحتی تغییرات مورد نظر خود را در محتوای صفحه اعمال کنید و به صورت پویا با صفحه تعامل داشته باشید. این تغییرات بدون نیاز به بارگذاری مجدد صفحه اعمال می‌شوند که تجربه کاربر را بهبود می‌بخشد.</p>"
  },
  {
    "title": "47- تفاوت classList و className ؟",
    "answer": "<p>تفاوت اصلی بین classList و className در جاوااسکریپت در روشی است که با آنها کلاس‌ها بر روی عناصر DOM مدیریت می‌شوند. <br /> <span>classList</span> یک ویژگی (property) است که به عناصر DOM اضافه شده است و یک مجموعه (Set) از توابع و متد‌ها را برای مدیریت کلاس‌ها فراهم می‌کند. <br /> این متد‌ها شامل add()، remove()، toggle() و contains() است که به ترتیب برای اضافه کردن کلاس، حذف کردن کلاس، تغییر وضعیت کلاس و بررسی وجود کلاس استفاده می‌شوند. <br /> با استفاده از classList، می‌توانید کلاس‌ها را به صورت جداگانه اضافه، حذف و مدیریت کنید. <code> element.classList.add('newClass'); // اضافه کردن کلاس جدید<br /> element.classList.remove('class1'); // حذف کلاس موجود<br /> element.classList.contains('class2'); // بررسی وجود یک کلاس </code> <span>className</span> یک ویژگی است که مستقیماً متن رشته‌ای (String) از کلاس‌های یک المان DOM را برمی‌گرداند. <br /> این رشته شامل تمام کلاس‌های اختصاص داده شده به عنصر می‌باشد و می‌توان با تغییر مقدار آن، کلاس‌ها را به صورت کلی جایگزین کرد. <br /> با استفاده از className، شما می‌توانید کلاس‌های عنصر را به صورت رشته‌ای دریافت یا تنظیم کنید، اما امکان اعمال تغییرات دقیق به کلاس‌ها مثل add() و remove() که در classList وجود دارد، وجود ندارد. <code> var allClasses = element.className; // 'class1 class2 class3'<br /> element.className += ' newClass'; // اضافه کردن کلاس جدید </code> <br /> با توجه به این تفاوت، استفاده از classList معمولاً اولویت بیشتری نسبت به className دارد، زیرا این امکان را فراهم می‌کند تا کلاس‌ها به صورت جداگانه مدیریت شوند و برای اضافه کردن، حذف کردن یا تغییر وضعیت کلاس‌ها از توابع خاصی استفاده شود.</p>"
  },
  {
    "title": "48- dataset و کاربرد آن ؟",
    "answer": "<p><strong>dataset</strong> یک ویژگی در المان‌های DOM در جاوااسکریپت است که به شما امکان می‌دهد داده‌های مختلف را به صورت سفارشی به عناصر HTML اضافه کنید و از آنها در جاوااسکریپت استفاده کنید. این ویژگی بسیار مفید است زمانی که نیاز به اتصال داده‌های اضافی به عناصر HTML دارید و نمی‌خواهید از ویژگی‌های استانداردی مانند class یا id استفاده کنید. <br /> به طور معمول، dataset برای دسترسی به داده‌هایی استفاده می‌شود که با ویژگی data-* در HTML تعریف شده‌اند. به عنوان مثال، فرض کنید می‌خواهید اطلاعاتی را به یک المان HTML اضافه کنید و در جاوااسکریپت استفاده کنید. می‌توانید به صورت زیر این کار را انجام دهید: <br /> <small>HTML:</small> <code> id='myElement' data-name='John' data-age='30' </code> <small>JavaScript:</small> <code> var element = document.getElementById('myElement');<br /> var name = element.dataset.name; // مقدار داده به نام 'name'<br /> var age = element.dataset.age; // مقدار داده به نام 'age' </code> در اینجا، با استفاده از dataset، می‌توانیم به آسانی به داده‌های data-name و data-age دسترسی پیدا کنیم و از آنها در جاوااسکریپت استفاده کنیم. <br /> استفاده از dataset بسیار مفید است زمانی که نیاز به ارتباط داده‌های سفارشی با عناصر HTML دارید و می‌خواهید این داده‌ها را در داخل سکوپ عملیات جاوااسکریپت خود استفاده کنید. این روش به شما امکان می‌دهد داده‌های بیشتری را به المان‌های HTML اضافه کنید و کنترل بیشتری بر روی آنها داشته باشید.</p>"
  },
  {
    "title": "49- کاربرد fetch ؟",
    "answer": "<p><strong>fetch</strong> یک روش در جاوااسکریپت است که برای ارسال درخواست‌های شبکه (network requests) استفاده می‌شود. این روش برای ارسال درخواست‌های HTTP به سرور و دریافت پاسخ‌های آن استفاده می‌شود، به طور معمول برای دریافت داده‌های JSON، XML یا متنی از سرور و انجام عملیات مرتبط با API به کار می‌رود. <br /> <span>کاربرد fetch به طور خلاصه عبارت است از:</span><br /> <small>ارسال درخواست به یک URL مشخص.</small> <br /> <small> دریافت پاسخ از سرور به صورت ناهمگام (asynchronous).</small><br /> <small> پردازش و استفاده از داده‌های دریافتی در جاوااسکریپت.</small><br /> در قبل از fetch، برای ارسال درخواست‌های شبکه از XMLHttpRequest استفاده می‌شد که نحوه استفاده از آن پیچیده‌تر بود. با معرفی fetch، امکانات بهتری در خصوص مدیریت درخواست‌های شبکه و پردازش پاسخ‌ها ایجاد شد. <br /> نمونه استفاده از fetch برای دریافت داده‌ها به صورت زیر است: <code> fetch('https://api.example.com/data')<br /> .then(response => response.json())<br /> .then(data => console.log(data))<br /> .catch(error => console.error('Error:', error)); </code> در این مثال، ابتدا یک درخواست GET به URL مورد نظر ارسال می‌شود. سپس پس از دریافت پاسخ، آن را به فرمت JSON تبدیل می‌کنیم و از آن استفاده می‌کنیم. در صورت بروز خطا، می‌توانیم آن را نیز در خطاگیری (error handling) پردازش کنیم. <br /> با استفاده از fetch، می‌توانید درخواست‌هایی به سرور ارسال کنید و پاسخ‌های آن را دریافت کنید، بدون نیاز به استفاده از کتابخانه‌های جانبی. این امر کد را ساده‌تر می‌کند و از نظر کارایی بهبود می‌بخشد.</p>"
  },
  {
    "title": "50- انواع http method ها ؟",
    "answer": "<p><strong>HTTP (Hypertext Transfer Protocol) </strong>مجموعه‌ای از قوانین و استانداردهایی است که برای ارسال و دریافت اطلاعات از اینترنت استفاده می‌شود. در HTTP، ارسال و دریافت اطلاعات از طریق متدهای مختلفی صورت می‌گیرد که به عنوان 'HTTP Methods' یا 'HTTP Verbs' شناخته می‌شوند. در زیر تعدادی از انواع رایج HTTP Methods آورده شده است: <br /> <small>GET:</small> برای دریافت اطلاعات از سرور استفاده می‌شود. درخواست GET به سرور ارسال می‌شود و سرور پاسخ متناظر با درخواست را برمی‌گرداند. <br /> <small>POST:</small> برای ارسال داده‌هایی به سرور استفاده می‌شود. این داده‌ها ممکن است به صورت فرم داده شود، مثلاً ارسال اطلاعات ورود کاربر یا ارسال اطلاعات به سرور برای ذخیره سازی. <br /> <small>PUT:</small> برای به‌روزرسانی اطلاعات موجود در سرور استفاده می‌شود. این متد معمولاً برای بروزرسانی منابع خاص در سرور استفاده می‌شود. <br /> <small>DELETE:</small> برای حذف اطلاعات موجود در سرور استفاده می‌شود. با استفاده از این متد، می‌توانید اطلاعات یک منبع خاص را از سرور حذف کنید. <br /> <small>PATCH:</small> برای به‌روزرسانی جزئی اطلاعات موجود در سرور استفاده می‌شود. این متد برای ارسال تغییرات جزئی به داده‌های موجود استفاده می‌شود، بدون اینکه داده‌های دیگر را تغییر دهد. <br /> <small>OPTIONS:</small> برای دریافت اطلاعاتی در مورد قابلیت‌ها و تنظیمات موجود در سرور استفاده می‌شود، مثلاً دریافت اطلاعات در مورد مجوزهایی که باید برای ارسال یک درخواست خاص به سرور وجود داشته باشد. <br /> <small>HEAD:</small> مشابه متد GET است، با این تفاوت که فقط هدر درخواست و پاسخ ارسال می‌شود، بدون ارسال بدنه (body) اطلاعات. <br /> <small>TRACE:</small> برای دریافت کپی از درخواستی که ارسال می‌شود به سرور استفاده می‌شود. این متد معمولاً برای تست و یا اشکال‌زدایی درخواست‌های HTTP استفاده می‌شود. <br /> <small>CONNECT: </small> برای ایجاد یک تونل به سرور از طریق پروکسی استفاده می‌شود. این متد معمولاً در تکنولوژی‌های امنیتی مانند HTTPS استفاده می‌شود. <br /> این فقط چند نمونه از انواع مختلف HTTP Methods هستند که در ارتباط با سرورها استفاده می‌شوند. هرکدام از این متدها وظایف و کاربردهای متفاوتی دارند و بر اساس نیازهای خاص، از آنها استفاده می‌شود.</p>"
  },
  {
    "title": "51- تفاوت get و post ؟",
    "answer": "<p>تفاوت اصلی بین متدهای GET و POST در HTTP این است که GET برای دریافت داده از سرور استفاده می‌شود، در حالی که POST برای ارسال داده به سرور استفاده می‌شود. این دو متد در مواقع مختلف و برای اهداف متفاوت استفاده می‌شوند و دارای خصوصیات ویژه‌ای هستند: <br /> <span>GET:</span> <br /> اطلاعات درخواستی به صورت پارامترهای URL ارسال می‌شود (Query String).<br /> محدودیت در طول URL دارد و اطلاعات محدودی می‌تواند ارسال شود.<br /> مناسب برای درخواست داده‌هایی که نیاز به ارسال اطلاعات کم دارند، مانند درخواست صفحات وب، جستجوها و غیره.<br /> داده‌های ارسال شده در درخواست به صورت قابل خواندن بر روی آدرس URL نمایش داده می‌شوند.<br /> <span>POST:</span> <br /> اطلاعات درخواستی به صورت بدنه‌ی درخواست (Request Body) ارسال می‌شوند.<br /> محدودیت در اندازه داده‌ها ندارد و می‌تواند داده‌های بزرگ‌تری را ارسال کند.<br /> مناسب برای ارسال داده‌های حساس و مهم که نیاز به مخفی کردن درخواست دارند مانند ارسال اطلاعات فرم‌ها و داده‌های کاربری.<br /> داده‌های ارسال شده در درخواست به صورت مخفی ارسال می‌شوند و برای دیدن آنها نیاز به ابزارهای خاصی می‌باشد.<br /> به طور خلاصه، GET بیشتر برای دریافت داده‌ها و نمایش آنها استفاده می‌شود، در حالی که POST بیشتر برای ارسال داده‌ها و انجام عملیات‌های مهم استفاده می‌شود. انتخاب بین این دو متد باید بر اساس نیازهای خاص و اهداف درخواست شما صورت گیرد.</p>"
  },
  {
    "title": "52- jwt چیست ؟",
    "answer": "<p><strong>JWT</strong> مخفف عبارت 'JSON Web Token' است. این استاندارد یک روش امن برای انتقال اطلاعات بین دو طرف در یک شبکه‌ی اطلاعاتی است. JWT به عنوان یک روش احراز هویت (authentication) و اعتبارسنجی (verification) برای برنامه‌های وب استفاده می‌شود و به صورت کلی به صورت یک رشته‌ی متنی تشکیل شده از سه بخش مختلف است: Header، Payload و Signature. <br /> <small>Header (هدر):</small> قسمت اول یک JWT، که Base64 encoded می‌شود، هدر است. این هدر حاوی اطلاعاتی در مورد نوع توکن و نوع رمزگذاری استفاده شده برای ایجاد توکن است. <br /> <small>Payload (بار مفید):</small> قسمت دوم یک JWT، نیز Base64 encoded می‌شود و معمولاً اطلاعات کاربر یا اطلاعات مربوط به دسترسی‌ها یا اجازه‌هایی که کاربر دارد را شامل می‌شود. <br /> <small>Signature (امضاء):</small> قسمت سوم یک JWT، برای اعتبارسنجی توکن استفاده می‌شود. این بخش شامل امضای دیجیتالی است که توسط سرور ایجاد می‌شود و با استفاده از هدر و بار مفید، برای اطمینان از اینکه توکن تغییر نکرده است، بررسی می‌شود. <br /> JWT به طور گسترده در امنیت وب مورد استفاده قرار می‌گیرد، به خصوص برای سیستم‌های مبتنی بر توکن‌های احراز هویت مانند OAuth و در فرآیندهای مبتنی بر وب‌سرویس‌ها (Web Services) که نیاز به احراز هویت و مجوز دسترسی دارند. از جمله کاربردهای JWT می‌توان به مدیریت جلسات کاربر، احراز هویت دوعاملی (two-factor authentication)، و تصدیق داده‌ها اشاره کرد. از آنجایی که JWT اطلاعات حساسی را در خود دارد، باید با دقت و مراقبت استفاده شود تا امنیت داده‌ها حفظ شود.</p>"
  },
  {
    "title": "53- تفاوت authentication و authorization ؟",
    "answer": "<p>تفاوت اصلی بین Authentication و Authorization در این است که Authentication (احراز هویت) تعیین می‌کند که یک کاربر آیا هویت اعلام شده را دارد یا خیر، در حالی که Authorization (مجوز دسترسی) تعیین می‌کند که یک کاربر دارای مجوز برای دسترسی به یک منبع خاص است یا خیر. <br /> <span>Authentication (احراز هویت): </span><br /> احراز هویت به فرآیند تشخیص و تایید هویت یک کاربر می‌پردازد. در این فرآیند، کاربر شناسایی می‌شود و اطلاعات مورد نیاز برای اثبات هویت (مانند نام کاربری و رمز عبور) ارائه می‌شود. مثالهایی از روشهای احراز هویت شامل ورود به سیستم با نام کاربری و رمز عبور، احراز هویت دو عاملی (two-factor authentication)، و استفاده از توکن‌های امنیتی مانند JWT می‌شود. <br /> <span>Authorization (مجوز دسترسی):</span><br /> مجوز دسترسی تعیین می‌کند که کاربر دارای مجوز برای دسترسی به یک منبع (مثلاً فایل، صفحه وب، یا سرویس) خاص است یا خیر. این مجوزها بر مبنای هویت کاربر تعیین می‌شود و می‌توانند بر اساس نقش، دسترسی‌های مشخص، یا دیگر معیارها تعیین شوند. مثالهایی از مجوزها شامل دسترسی به صفحات مدیریتی توسط مدیران، دسترسی به منابع حساس توسط کاربران مجاز، و موارد مشابه است. <br /> به طور خلاصه، احراز هویت مشخص می‌کند که کاربر کیست، در حالی که مجوز دسترسی تعیین می‌کند که چه کاری کاربر می‌تواند انجام دهد. این دو مفهوم معمولاً با هم استفاده می‌شوند و اساس امنیت وب و کنترل دسترسی به منابع را تشکیل می‌دهند.</p>"
  },
  {
    "title": "54- form validation چیست ؟",
    "answer": "<p>فرم‌ها یکی از ابزارهای اصلی برای ارتباط با کاربران در وبسایت‌ها هستند. اما برای اطمینان از صحت و کارایی داده‌هایی که کاربران در این فرم‌ها وارد می‌کنند، فرم‌ها باید اعتبارسنجی یا (form validation) شوند. <br /> Form validation به معنای اعتبارسنجی داده‌های ورودی است که توسط کاربران در فرم‌های وب وارد می‌شوند. این اعتبارسنجی معمولاً در زمانی که کاربران اطلاعات را در فرم وارد می‌کنند، صورت می‌گیرد و می‌تواند شامل چک کردن صحت فرمت داده‌ها، بررسی وجود الزامی بودن فیلدها، و اعتبارسنجی مقادیر داده شده توسط کاربر باشد. <br /> <span>برخی از مواردی که در اعتبارسنجی فرم‌ها مورد بررسی قرار می‌گیرند عبارتند از: </span><br /> <small>صحت فرمت داده‌ها:</small> برای مثال، یک ایمیل باید دارای فرمت مناسبی باشد (مانند example@example.com). <br /> <small>پر بودن فیلدهای الزامی:</small> فیلدهایی که الزامی هستند باید حتما پر شوند. <br /> <small>حداقل و حداکثر طول یا محدودیت‌های عددی:</small> مثلاً برای یک فیلد مربوط به وزن، می‌توان حداقل و حداکثر مقدار مجاز را مشخص کرد. <br /> <small>تطابق با الگوهای خاص:</small> برای مثال، یک رمز عبور باید حاوی حروف بزرگ، حروف کوچک، اعداد و حداقل یک نماد خاص باشد. <br /> اعتبارسنجی فرم‌ها مهم است چرا که کمک می‌کند تا از ارسال داده‌های نامناسب و ناصحیح جلوگیری شود و اطمینان حاصل شود که فرم‌های ارسالی دارای داده‌های صحیح و قابل استفاده هستند. این کار باعث بهبود تجربه کاربری می‌شود و می‌تواند به جلوگیری از مشکلات امنیتی ناشی از داده‌های نامناسب کمک کند.</p>"
  },
  {
    "title": "55- نحوه هندل کردن error ها در جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، معمولاً از چند روش برای هندل کردن خطاها یا errors استفاده می‌شود. این شامل استفاده از try-catch blocks، استفاده از متد‌های Promise برای اعلام خطاها و همچنین استفاده از متد‌های مربوط به رویدادها (Event handlers) می‌شود. در زیر به این روش‌ها بیشتر می‌پردازیم: <br /> <span>try-catch blocks: </span><br /> این روش معمولاً برای هندل کردن خطاهایی استفاده می‌شود که درون یک بلوک کد مشخص اتفاق می‌افتد. با استفاده از try-catch می‌توانید کد را اجرا کنید و در صورت بروز خطا، اطلاعات خطا را در بخش catch دریافت کنید و با آن برخورد کنید. مثال: <code> try {<br /> // کدی که ممکن است خطا داشته باشد<br /> } catch(error) {<br /> // برخورد با خطا و انجام عملیات مورد نظر<br /> console.error('Error:', error);<br /> } </code> <span>Promises: </span> <br /> با استفاده از متد then و catch می‌توانید خطاها را در promise ها هندل کنید. متد catch برای گرفتن هندل خطا استفاده می‌شود. مثال: <code> someAsyncFunction()<br /> .then(result => {<br /> // کارهایی با نتیجه انجام می‌دهیم<br /> })<br /> .catch(error => {<br /> // برخورد با خطا و انجام عملیات مورد نظر<br /> console.error('Error:', error);<br /> }); </code> <span>Event handlers: </span> <br /> برای هندل کردن خطاهای مربوط به رویدادها، می‌توانید متدهایی مانند onerror برای رویدادهای وب استفاده کنید. مثال: <code> window.onerror = function(message, source, lineno, colno, error) {<br /> // برخورد با خطا و انجام عملیات مورد نظر<br /> console.error('Error:', error);<br /> }; </code> این روش‌ها بسته به محیط و شرایط کاربرد متفاوتی دارند و باید با توجه به نیازهای خاص پروژه و محیط استفاده شوند.</p>"
  },
  {
    "title": "56- finally در جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، کلمه کلیدی finally در کنار try و catch برای اجرای یک بخش کد بعد از اجرای بلاک try و catch به کار می‌رود. بخش کد موجود در بلاک finally همیشه اجرا می‌شود، بدون وابستگی به اینکه آیا خطا اتفاق افتاده است یا خیر. این کاربردی مشابه کاربردی دارد که برای اجرای بخش‌های پایانی در زمانی که ممکن است اشکالی اتفاق بیفتد، مورد نیاز باشد. <br /> با استفاده از بلاک finally، می‌توانید کدهایی که باید در پایان برنامه اجرا شوند (مانند رفع منابع، پاکسازی، یا انجام عملیات مرتبط با پایان اجرا) را انجام دهید، بدون اینکه نگرانی در مورد اینکه آیا خطایی رخ داده است یا نه، داشته باشید. <br /> مثال: <code> try {<br /> // کدی که ممکن است خطا داشته باشد<br /> } catch(err) {<br /> // برخورد با خطا<br /> console.error(err);<br /> } finally {<br /> // بخشی که همیشه اجرا می‌شود<br /> console.log('Finally block executed');<br /> } </code> به عبارت دیگر، بخش کد موجود در بلاک finally، بعد از اتمام بخش کد موجود در بلاک try (در صورتی که خطا نیز رخ ندهد) یا بلاک catch (در صورتی که خطا رخ دهد) اجرا می‌شود.</p>"
  },
  {
    "title": "57- throw در جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، کلمه کلیدی throw برای ایجاد و پرتاب (throw) یک خطا یا استثناء استفاده می‌شود. زمانی که یک خطایی رخ می‌دهد و برنامه نمی‌تواند به طور عادی ادامه پیدا کند، می‌توانید با استفاده از throw یک استثناء ایجاد کنید تا اطلاعاتی در مورد خطا را به برنامه ارسال کنید و اجازه دهید که برنامه به درستی مدیریت شود یا اجرا متوقف شود. <br /> مثال: <code> function divide(a, b) {<br /> if (b === 0) {<br /> throw new Error('Divide by zero error');<br /> }<br /> return a / b;<br /> }<br /> try {<br /> console.log(divide(6, 0));<br /> } catch(error) {<br /> console.error('Error:', error.message);<br /> } </code> در این مثال، تابع divide بررسی می‌کند که آیا مخرج عدد صفر است یا نه؛ اگر صفر باشد، یک خطای جدید ایجاد می‌شود و توسط throw پرتاب می‌شود. سپس با استفاده از try-catch، این خطا مدیریت شده و پیام خطا نمایش داده می‌شود. <br /> به طور کلی، استفاده از throw به برنامه نویسان امکان می‌دهد تا خطاها را به طور دستی مدیریت کنند و باعث ایجاد کدی مطمئن و قابل اطمینان شوند که با خطاها به درستی برخورد شده است.</p>"
  },
  {
    "title": "58- تاریخ و زمان در جاوااسکریپت ؟",
    "answer": "<p>در جاوااسکریپت، شما می‌توانید با استفاده از شی Date به تاریخ و زمان دسترسی داشته باشید و با آنها کار کنید. شی Date یک نوع داده‌ای از جاوااسکریپت است که امکانات مربوط به تاریخ و زمان را فراهم می‌کند. <br /> برای ایجاد یک شی Date می‌توانید از روش‌های مختلفی استفاده کنید، از جمله: <br /> <span>استفاده از سازنده بدون پارامتر: </span> <code> const currentDate = new Date(); </code> <span>استفاده از سازنده با تاریخ و زمان مشخص: </span> <code> const specificDate = new Date('2024-02-18T12:00:00'); </code> <span>استفاده از سازنده با میلی‌ثانیه: </span> <code> const millisecondsDate = new Date(1613640000000); // میلی‌ثانیه‌های گذشته از 1 ژانویه 1970 </code> بعد از ایجاد یک شی Date، می‌توانید از متد‌های آن برای دسترسی به اطلاعات مربوط به تاریخ و زمان استفاده کنید. برخی از این متدها شامل: <br /> <small>getFullYear():</small> برگرداندن سال.<br /> <small>getMonth():</small> برگرداندن ماه (با شماره 0 تا 11).<br /> <small>getDate():</small> برگرداندن روز از ماه (1 تا 31).<br /> <small>getDay():</small> برگرداندن روز از هفته (0 تا 6، که 0 یکشنبه و 6 شنبه است).<br /> <small>getHours():</small> برگرداندن ساعت (0 تا 23).<br /> <small>getMinutes():</small> برگرداندن دقیقه (0 تا 59).<br /> <small>getSeconds():</small> برگرداندن ثانیه (0 تا 59).<br /> همچنین، شی Date دارای متدهایی برای تنظیم تاریخ و زمان نیز می‌باشد، مانند setFullYear()، setMonth()، و غیره. <br /> به طور کلی، با استفاده از شی Date، شما می‌توانید تاریخ و زمان را مدیریت کرده و به صورت دقیق با آنها کار کنید.</p>"
  },
  {
    "title": "59- cors policy چیست ؟",
    "answer": "<p>سیاست CORS (Cross-Origin Resource Sharing) یک مکانیزم امنیتی در مرورگرهای وب است که به وب‌سایت‌ها اجازه می‌دهد منابع را با منابع از دامنه‌های مختلف به اشتراک بگذارند. وقتی که یک وب‌سایت درخواستی را از یک دامنه دیگر ارسال می‌کند (که از دامنه‌ی خود آن بازدید شده است)، مرورگر ابتدا یک درخواست OPTIONS را به دامنه مقصد ارسال می‌کند تا سرور اجازه‌ی ارسال منابع را تأیید کند. سپس اگر سرور پاسخی با کد استاتوس 200 به این درخواست OPTIONS ارسال کند که حاوی اطلاعات کنترل دسترسی به منابع (Access-Control-Allow-Origin، Access-Control-Allow-Methods و غیره) است، مرورگر اجازه‌ی ارسال و دریافت منابع را می‌دهد. <br /> این مکانیزم برای جلوگیری از حملات CSRF (Cross-Site Request Forgery) و افزایش امنیت در مرورگرها تعبیه شده است. بدون اعمال سیاست CORS، مرورگرها به طور پیش‌فرض جلوگیری از درخواست‌های منبع را انجام می‌دهند و درخواست‌هایی که از دامنه‌های مختلفی صادر شده‌اند را رد می‌کنند. <br /> سیاست CORS شامل چندین متن کنترلی است که به وب سرورها اجازه می‌دهد تا محدودیت‌هایی را در مورد ارسال یا دریافت منابع به دامنه‌های دیگر تعیین کنند، از جمله: <br /> <small>Access-Control-Allow-Origin:</small> این هدر به وب‌سایت‌ها اجازه می‌دهد منابع خود را با دامنه‌های مشخص شده به اشتراک بگذارند. <br /> <small>Access-Control-Allow-Methods:</small> این هدر مشخص می‌کند که کدام متد‌های HTTP (مانند GET، POST، PUT، DELETE و غیره) مجاز به استفاده در درخواست‌های ارسالی از دامنه دیگر هستند. <br /> <small>Access-Control-Allow-Headers:</small> این هدر مشخص می‌کند که چه نوع هدرهای HTTP در درخواست‌های ارسالی از دامنه دیگر مجاز استفاده شوند. <br /> با تعیین این هدرها، وب‌سرورها می‌توانند کنترل کنند که چه دامنه‌هایی می‌توانند به منابع آنها دسترسی پیدا کنند و چه عملیاتی از طریق درخواست‌های دیگر مجاز است.</p>"
  },
  {
    "title": "60- حملات xss چیست ؟",
    "answer": "<p>حملات XSS (Cross-Site Scripting) نوعی حملات امنیتی در وب هستند که به کاربران و وب‌سایت‌ها آسیب می‌زنند. در این نوع حملات، حمله‌کننده از طریق درج کد اسکریپت (معمولاً JavaScript) در یک صفحه وب، توانایی اجرای کد را در مرورگر کاربران هدف خود فراهم می‌کند. این کدها معمولاً از طریق فرم‌ها، تگ‌های HTML، پارامترهای URL و دیگر ورودی‌های کاربر ارسال می‌شوند. <br /> <span>حملات XSS می‌توانند به دو صورت انجام شوند: </span><br /> <small>Reflected XSS (XSS منعکس شده):</small> در این نوع حملات، کد مخرب به صورت مستقیم در URL یا فرم‌های ورودی وب‌سایت قرار می‌گیرد و سپس توسط سرور برگشت داده می‌شود و در مرورگر کاربر اجرا می‌شود. <br /> <small>Stored XSS (XSS ذخیره شده):</small> در این نوع حملات، کد مخرب توسط حمله‌کننده به یک بخش از وب‌سایت (مثلاً بخش نظرات یا ارسال پیام) ارسال می‌شود و سپس توسط همه کاربرانی که آن بخش را مشاهده می‌کنند، اجرا می‌شود. <br /> تأثیر حملات XSS می‌تواند بسیار وسیع باشد و شامل انجام عملیات ناخواسته در مرورگر کاربران، دزدیده شدن اطلاعات کاربری مانند نام کاربری و رمز عبور، ردیابی فعالیت‌های کاربر، و حتی به کنترل کامل مرورگر کاربر توسط حمله‌کننده شامل می‌شود. <br /> برای جلوگیری از حملات XSS، می‌توان از روش‌هایی مانند اسکیپ (escape) کردن ورودی‌های کاربر، فیلتر کردن ورودی‌های ناخواسته، استفاده از CSP (Content Security Policy)، و تمرین بهترین روش‌های امنیتی در توسعه وب‌سایت استفاده کرد.</p>"
  }
]
